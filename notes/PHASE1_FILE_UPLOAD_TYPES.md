# Phase 1: File Upload Types - Technical Design

## Goal
Generate type-safe file upload handling in Elm + JavaScript from Rust domain types. Eliminate the manual multipart form boilerplate that every app implements.

## Domain Types Definition

```rust
// Define file upload capability in your app
#[derive(BuildAmpFileUpload, Debug, Clone)]
pub struct PhotoUploadReq {
    pub album_id: String,
    pub caption: Option<String>,
    // File constraints defined as types
    pub constraints: FileConstraints,
}

#[derive(BuildAmpElm, Debug, Clone)]
pub struct FileConstraints {
    pub max_size_mb: u32,
    pub allowed_types: Vec<String>, // ["image/jpeg", "image/png"]
    pub multiple: bool,
}

#[derive(BuildAmpElm, Debug, Clone)]
pub struct PhotoUploadResp {
    pub photo_id: String,
    pub url: String,
    pub thumbnail_url: Option<String>,
}

// File info passed from browser
#[derive(BuildAmpElm, Debug, Clone)]
pub struct FileInfo {
    pub name: String,
    pub size: u64,
    pub content_type: String,
    pub last_modified: u64,
}
```

## Generated Elm Code

```elm
-- Generated module: Api.PhotoUpload
module Api.PhotoUpload exposing (..)

import File exposing (File)
import Http
import Json.Decode as Decode
import Json.Encode as Encode

-- Generated types
type alias PhotoUploadReq =
    { albumId : String
    , caption : Maybe String
    , constraints : FileConstraints
    }

type alias FileConstraints =
    { maxSizeMb : Int
    , allowedTypes : List String
    , multiple : Bool
    }

type alias PhotoUploadResp =
    { photoId : String
    , url : String
    , thumbnailUrl : Maybe String
    }

type alias FileInfo =
    { name : String
    , size : Int
    , contentType : String
    , lastModified : Int
    }

-- Generated file upload function
uploadPhoto : PhotoUploadReq -> List File -> Cmd Msg
uploadPhoto req files =
    let
        parts =
            [ Http.stringPart "album_id" req.albumId
            , Http.stringPart "caption" (req.caption |> Maybe.withDefault "")
            , Http.stringPart "constraints" (encodeFileConstraints req.constraints)
            ]
            ++ List.indexedMap filePartWithValidation files
    in
    Http.request
        { method = "POST"
        , headers = []
        , url = "/api/photos/upload"
        , body = Http.multipartBody parts
        , expect = Http.expectJson PhotoUploadComplete decodePhotoUploadResp
        , timeout = Nothing
        , tracker = Nothing
        }

-- Generated file validation
filePartWithValidation : Int -> File -> Http.Part
filePartWithValidation index file =
    -- File validation would happen in generated JS
    Http.filePart ("file_" ++ String.fromInt index) file

-- Generated JSON codecs (normal BuildAmp generation)
encodeFileConstraints : FileConstraints -> String
encodeFileConstraints constraints = 
    Encode.encode 0 <|
        Encode.object
            [ ("max_size_mb", Encode.int constraints.maxSizeMb)
            , ("allowed_types", Encode.list Encode.string constraints.allowedTypes)
            , ("multiple", Encode.bool constraints.multiple)
            ]

decodePhotoUploadResp : Decode.Decoder PhotoUploadResp
decodePhotoUploadResp =
    Decode.map3 PhotoUploadResp
        (Decode.field "photo_id" Decode.string)
        (Decode.field "url" Decode.string)
        (Decode.field "thumbnail_url" (Decode.nullable Decode.string))
```

## Generated JavaScript File Upload Handler

```javascript
// Generated: photo_upload_handler.js
// Auto-generated by Hamlet - do not edit manually

export function setupPhotoUploadHandler(app) {
    console.log('ðŸ”§ Setting up photo upload capability');
    
    // File validation based on generated constraints
    function validateFiles(files, constraints) {
        const errors = [];
        
        if (!constraints.multiple && files.length > 1) {
            errors.push('Multiple files not allowed');
        }
        
        for (const file of files) {
            // Size validation
            if (file.size > constraints.max_size_mb * 1024 * 1024) {
                errors.push(`File ${file.name} exceeds ${constraints.max_size_mb}MB limit`);
            }
            
            // Type validation
            if (constraints.allowed_types.length > 0) {
                const allowed = constraints.allowed_types.some(pattern => {
                    if (pattern.endsWith('/*')) {
                        return file.type.startsWith(pattern.slice(0, -1));
                    }
                    return file.type === pattern;
                });
                
                if (!allowed) {
                    errors.push(`File ${file.name} type ${file.type} not allowed`);
                }
            }
        }
        
        return errors;
    }
    
    // Enhanced file picker with constraints
    window.PhotoUpload = {
        pickFiles: function(constraints) {
            return new Promise((resolve) => {
                const input = document.createElement('input');
                input.type = 'file';
                input.multiple = constraints.multiple;
                input.accept = constraints.allowed_types.join(',');
                
                input.onchange = () => {
                    if (input.files && input.files.length > 0) {
                        const files = Array.from(input.files);
                        const errors = validateFiles(files, constraints);
                        
                        if (errors.length > 0) {
                            resolve({ type: 'ValidationError', errors: errors });
                        } else {
                            const fileInfos = files.map(file => ({
                                name: file.name,
                                size: file.size,
                                content_type: file.type,
                                last_modified: file.lastModified,
                                _file: file // Keep reference for upload
                            }));
                            resolve({ type: 'FilesSelected', files: fileInfos });
                        }
                    } else {
                        resolve({ type: 'Cancelled' });
                    }
                    
                    document.body.removeChild(input);
                };
                
                input.oncancel = () => {
                    resolve({ type: 'Cancelled' });
                    document.body.removeChild(input);
                };
                
                input.style.display = 'none';
                document.body.appendChild(input);
                input.click();
            });
        }
    };
    
    // If using ports for file picker (optional enhancement)
    if (app.ports && app.ports.pickPhotoFiles) {
        app.ports.pickPhotoFiles.subscribe(async (constraints) => {
            const result = await window.PhotoUpload.pickFiles(constraints);
            if (app.ports.photoFilesResult) {
                app.ports.photoFilesResult.send(result);
            }
        });
    }
}

// Auto-initialize if Elm app is available
document.addEventListener('DOMContentLoaded', () => {
    if (window.Elm && window.Elm.Main && window.Elm.Main.init) {
        // Wait for Elm app to be available
        setTimeout(() => {
            const app = document.querySelector('[data-elm-app]')?.__elm_app;
            if (app) {
                setupPhotoUploadHandler(app);
            }
        }, 100);
    }
});
```

## Server-Side Integration (Your Choice)

The generated types work with any server implementation:

### Express.js Example
```javascript
const multer = require('multer');
const upload = multer({ dest: 'uploads/' });

app.post('/api/photos/upload', upload.array('file'), (req, res) => {
    const { album_id, caption, constraints } = req.body;
    const files = req.files;
    
    // Your business logic here
    const photoId = savePhotoToDatabase(album_id, caption, files);
    const url = generatePhotoUrl(photoId);
    
    res.json({ 
        photo_id: photoId, 
        url: url,
        thumbnail_url: null 
    });
});
```

### Rust/Axum Example
```rust
async fn upload_photo(
    req: PhotoUploadReq,
    files: Vec<UploadedFile>
) -> Result<PhotoUploadResp> {
    // Constraints already validated by generated JS
    let photo_id = save_photo(req.album_id, req.caption, files).await?;
    let url = generate_photo_url(&photo_id);
    
    Ok(PhotoUploadResp {
        photo_id,
        url,
        thumbnail_url: None,
    })
}
```

## Hamlet Code Generation Process

### 1. Detect `#[derive(BuildAmpFileUpload)]`
```rust
// In hamlet-macro/src/lib.rs
#[proc_macro_derive(BuildAmpFileUpload)]
pub fn derive_file_upload(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    
    // Generate normal BuildAmp types + file upload enhancements
    let normal_output = generate_buildamp_endpoint(&ast);
    let file_upload_output = generate_file_upload_js(&ast);
    
    quote! {
        #normal_output
        #file_upload_output
    }.into()
}
```

### 2. Generate JavaScript Handler
```rust
fn generate_file_upload_js(ast: &DeriveInput) -> TokenStream {
    let struct_name = &ast.ident;
    let js_filename = format!("{}_handler.js", struct_name.to_string().to_snake_case());
    
    // Extract FileConstraints field
    let constraints_field = extract_constraints_field(ast);
    
    // Generate JavaScript file
    let js_content = generate_js_handler(struct_name, &constraints_field);
    write_js_file(&js_filename, &js_content);
    
    // Return empty token stream (JS generation is side effect)
    quote! {}
}
```

### 3. Generate Enhanced Elm Types
```rust
fn generate_elm_file_upload(ast: &DeriveInput) -> String {
    let normal_elm = generate_normal_elm_types(ast);
    let upload_function = generate_elm_upload_function(ast);
    let file_picker_ports = generate_file_picker_ports(ast);
    
    format!("{}\n{}\n{}", normal_elm, upload_function, file_picker_ports)
}
```

## Integration with Build Process

### 1. Vite Plugin Enhancement
```javascript
// In existing vite plugin
export function hamletPlugin() {
    return {
        name: 'hamlet-file-upload',
        buildStart() {
            // Watch for generated JS handlers
            const handlerFiles = glob.sync('./generated/*_handler.js');
            for (const file of handlerFiles) {
                this.addWatchFile(file);
            }
        },
        generateBundle() {
            // Include generated handlers in bundle
            const handlers = loadGeneratedHandlers();
            this.emitFile({
                type: 'asset',
                fileName: 'hamlet-file-handlers.js',
                source: combineHandlers(handlers)
            });
        }
    };
}
```

### 2. Development Integration
```html
<!-- In your HTML -->
<script type="module">
    import './generated/photo_upload_handler.js';
    // Handler auto-registers when Elm app loads
</script>
```

## Usage Example (Complete Flow)

### 1. Define Types
```rust
#[derive(BuildAmpFileUpload)]
pub struct AvatarUploadReq {
    pub user_id: String,
    pub constraints: FileConstraints,
}
```

### 2. Use in Elm
```elm
-- Generated automatically
uploadAvatar : String -> Cmd Msg
uploadAvatar userId =
    let
        constraints = 
            { maxSizeMb = 5
            , allowedTypes = ["image/jpeg", "image/png"] 
            , multiple = False
            }
        
        req = 
            { userId = userId
            , constraints = constraints 
            }
    in
    -- Option 1: Use generated file picker
    pickPhotoFiles constraints |> Cmd.map FilesPicked
    
    -- Option 2: Use with existing file input
    -- Api.AvatarUpload.uploadAvatar req selectedFiles
```

### 3. Handle Result
```elm
type Msg
    = FilesPicked FilePickResult
    | UploadComplete (Result Http.Error AvatarUploadResp)

update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
    case msg of
        FilesPicked (FilesSelected files) ->
            let
                req = { userId = model.userId, constraints = avatarConstraints }
            in
            ( model, Api.AvatarUpload.uploadAvatar req (List.map .file files) )
            
        UploadComplete (Ok response) ->
            ( { model | avatarUrl = Just response.url }, Cmd.none )
```

## Benefits

1. **Zero Boilerplate**: No manual multipart form handling
2. **Type Safety**: File constraints defined in Rust, validated in JS
3. **Generated Validation**: Client-side validation based on constraints
4. **Server Agnostic**: Works with any backend that accepts multipart forms  
5. **Progressive Enhancement**: Apps can use basic file inputs or enhanced picker
6. **Transparent**: Generated JavaScript is readable and debuggable

## Limitations (By Design)

- **No Storage Opinions**: Apps handle file storage however they want
- **No Processing Pipeline**: Apps handle image resizing, etc. themselves
- **No Authentication**: Apps handle upload permissions themselves
- **No Progress Tracking**: Can be added later as enhancement

This keeps Hamlet focused on the **type-safe boundary** while making file uploads smooth for everyone who needs them.