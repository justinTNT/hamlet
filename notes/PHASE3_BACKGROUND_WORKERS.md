# Phase 3: Background Workers - Technical Design

## Minimal Effort Test
**Question**: Is this a small tweak to existing type generation, or a whole strategy?

**Answer**: Small tweak - just generate message types and postMessage handling for worker communication. No job queues, no retry logic, no worker lifecycle management.

## Goal
Generate type-safe worker communication from Rust message types. Eliminate manual postMessage boilerplate between main thread and workers.

## Domain Types Definition

```rust
// Define worker messages in your app
#[derive(BuildAmpWorker, Debug, Clone)]
pub enum ImageWorkerMessage {
    // Main ‚Üí Worker
    ProcessImage { 
        image_url: String, 
        max_width: u32,
        quality: u8,
    },
    
    // Worker ‚Üí Main  
    ProcessingComplete { 
        result_url: String,
        original_size: (u32, u32),
        final_size: (u32, u32),
    },
    ProcessingFailed { 
        error: String 
    },
    ProcessingProgress { 
        percent: f32 
    },
}

#[derive(BuildAmpWorker, Debug, Clone)]
pub enum DataWorkerMessage {
    // Main ‚Üí Worker
    ProcessCSV { data: String },
    CalculateStats { numbers: Vec<f64> },
    
    // Worker ‚Üí Main
    CSVProcessed { rows: u32, columns: Vec<String> },
    StatsCalculated { mean: f64, median: f64, std_dev: f64 },
    WorkerError { message: String },
}
```

## Generated Elm Code

```elm
-- Generated module: Workers.ImageWorker
module Workers.ImageWorker exposing (..)

import Json.Decode as Decode
import Json.Encode as Encode

-- Generated types
type ImageWorkerRequest
    = ProcessImage 
        { imageUrl : String
        , maxWidth : Int
        , quality : Int
        }

type ImageWorkerResponse
    = ProcessingComplete
        { resultUrl : String
        , originalSize : (Int, Int)
        , finalSize : (Int, Int)
        }
    | ProcessingFailed { error : String }
    | ProcessingProgress { percent : Float }

-- Generated worker functions
processImage : String -> Int -> Int -> Cmd Msg
processImage imageUrl maxWidth quality =
    sendToImageWorker (ProcessImage { 
        imageUrl = imageUrl, 
        maxWidth = maxWidth, 
        quality = quality 
    })

-- Generated subscription for worker responses
imageWorkerResponse : (ImageWorkerResponse -> msg) -> Sub msg
imageWorkerResponse toMsg =
    imageWorkerResponsePort (toMsg << decodeImageWorkerResponse)

-- Internal ports (generated, hidden from user)
sendToImageWorker : ImageWorkerRequest -> Cmd msg
imageWorkerResponsePort : (Decode.Value -> ImageWorkerResponse) -> Sub msg
```

## Generated JavaScript (Main Thread)

```javascript
// Generated: image_worker_main.js
// Auto-generated by Hamlet - do not edit manually

export function setupImageWorker(app) {
    console.log('üîß Setting up image worker communication');
    
    let worker = null;
    let messageId = 0;
    const pendingMessages = new Map();
    
    function ensureWorker() {
        if (!worker) {
            worker = new Worker('/workers/image_worker.js', { type: 'module' });
            
            worker.onmessage = (event) => {
                const { id, type, data } = event.data;
                
                // Send response to Elm
                if (app.ports && app.ports.imageWorkerResponsePort) {
                    app.ports.imageWorkerResponsePort.send({
                        type: type,
                        ...data
                    });
                }
                
                // Clean up pending message tracking if needed
                if (type.endsWith('Complete') || type.endsWith('Failed')) {
                    pendingMessages.delete(id);
                }
            };
            
            worker.onerror = (error) => {
                console.error('Image worker error:', error);
                if (app.ports && app.ports.imageWorkerResponsePort) {
                    app.ports.imageWorkerResponsePort.send({
                        type: 'ProcessingFailed',
                        error: 'Worker error: ' + error.message
                    });
                }
            };
        }
        return worker;
    }
    
    // Handle requests from Elm
    if (app.ports && app.ports.sendToImageWorkerPort) {
        app.ports.sendToImageWorkerPort.subscribe((request) => {
            const worker = ensureWorker();
            const id = ++messageId;
            
            worker.postMessage({
                id: id,
                type: request.type,
                data: request
            });
            
            pendingMessages.set(id, Date.now());
        });
    }
    
    // Cleanup
    window.addEventListener('beforeunload', () => {
        if (worker) {
            worker.terminate();
        }
    });
}
```

## Generated JavaScript (Worker Thread)

```javascript
// Generated: image_worker.js
// Auto-generated by Hamlet - do not edit manually

console.log('üéØ Image worker starting');

// Generated message handler
self.onmessage = async (event) => {
    const { id, type, data } = event.data;
    
    try {
        switch (type) {
            case 'ProcessImage':
                await handleProcessImage(id, data);
                break;
                
            default:
                self.postMessage({
                    id: id,
                    type: 'ProcessingFailed',
                    data: { error: `Unknown message type: ${type}` }
                });
        }
    } catch (error) {
        self.postMessage({
            id: id,
            type: 'ProcessingFailed',
            data: { error: error.message }
        });
    }
};

// TODO: Implement your processing logic
async function handleProcessImage(id, request) {
    const { imageUrl, maxWidth, quality } = request;
    
    // Send progress updates
    self.postMessage({
        id: id,
        type: 'ProcessingProgress',
        data: { percent: 0.1 }
    });
    
    // TODO: Your image processing logic here
    // This is where YOU implement the actual processing
    
    self.postMessage({
        id: id,
        type: 'ProcessingProgress', 
        data: { percent: 0.5 }
    });
    
    // Simulate processing (replace with real logic)
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Send completion
    self.postMessage({
        id: id,
        type: 'ProcessingComplete',
        data: {
            resultUrl: imageUrl + '?processed=true',
            originalSize: [1920, 1080],
            finalSize: [maxWidth, Math.floor(1080 * maxWidth / 1920)]
        }
    });
}

console.log('‚úÖ Image worker ready');
```

## Code Generation Process

```rust
// In hamlet-macro/src/lib.rs
#[proc_macro_derive(BuildAmpWorker)]
pub fn derive_worker(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    
    // Analyze enum to determine message flow
    let (to_worker, from_worker) = split_message_directions(&ast);
    
    // Generate Elm module
    let elm_output = generate_worker_elm(&ast, &to_worker, &from_worker);
    
    // Generate JavaScript main thread handler
    let main_js_output = generate_main_thread_js(&ast, &to_worker, &from_worker);
    
    // Generate JavaScript worker template  
    let worker_js_output = generate_worker_template(&ast, &to_worker);
    
    quote! {
        // Register for build system
        inventory::submit! {
            crate::elm_export::WorkerDefinition {
                worker_name: stringify!(#ast.ident),
                elm_module: #elm_output,
                main_js: #main_js_output,
                worker_js: #worker_js_output,
            }
        }
    }.into()
}

fn split_message_directions(ast: &DeriveInput) -> (Vec<Variant>, Vec<Variant>) {
    // Analyze enum variants to determine direction
    // Convention: variants ending in request/command go to worker
    // Variants ending in response/result/progress come from worker
}
```

## Usage Example

### 1. Define Worker Messages
```rust
#[derive(BuildAmpWorker)]
pub enum CSVWorkerMessage {
    ParseCSV { data: String },
    CSVParsed { rows: Vec<Vec<String>> },
    ParseError { error: String },
}
```

### 2. Use in Elm  
```elm
import Workers.CSVWorker as CSV

type Msg
    = ParseCSVClicked String
    | CSVResult CSV.CSVWorkerResponse

update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
    case msg of
        ParseCSVClicked csvData ->
            ( { model | status = "Parsing..." }
            , CSV.parseCSV csvData
            )
            
        CSVResult result ->
            case result of
                CSV.CSVParsed data ->
                    ( { model | csvData = data.rows, status = "Complete" }
                    , Cmd.none
                    )
                    
                CSV.ParseError error ->
                    ( { model | error = Just error.error, status = "Failed" }
                    , Cmd.none
                    )

subscriptions : Model -> Sub Msg
subscriptions model =
    CSV.csvWorkerResponse CSVResult
```

### 3. Implement Worker Logic
```javascript
// In generated csv_worker.js
async function handleParseCSV(id, request) {
    const { data } = request;
    
    try {
        // YOUR parsing logic here
        const rows = data.split('\n').map(line => line.split(','));
        
        self.postMessage({
            id: id,
            type: 'CSVParsed',
            data: { rows: rows }
        });
    } catch (error) {
        self.postMessage({
            id: id,
            type: 'ParseError', 
            data: { error: error.message }
        });
    }
}
```

### 4. Include Generated Files
```html
<script type="module">
    import './generated/csv_worker_main.js';
    // Worker communication auto-setup
</script>
```

## What This Provides (Minimal Effort)

‚úÖ **Type-safe worker communication** - No manual postMessage handling
‚úÖ **Generated Elm interfaces** - Clean worker functions and subscriptions  
‚úÖ **Worker lifecycle management** - Basic worker creation/cleanup
‚úÖ **Message ID tracking** - Correlate requests with responses
‚úÖ **Error handling** - Standard error patterns

## What This Doesn't Provide (Scope Boundaries)

‚ùå **Job queue systems** - Use your own queue (Redis, database, etc.)
‚ùå **Retry logic** - Implement in your worker code  
‚ùå **Worker pooling** - Use your own pool management
‚ùå **Task scheduling** - Use your own scheduler
‚ùå **Progress tracking persistence** - Store progress however you want
‚ùå **Worker discovery** - You decide which workers to create

## Minimal Effort Assessment

**Effort Level**: ‚≠ê‚≠ê (Small tweak)

**Why it passes**:
- Builds directly on existing type generation
- No new infrastructure required
- Generates standard postMessage code
- Worker implementation is just TODO comments
- No opinions about job management

**Key insight**: We're just eliminating the **postMessage boilerplate**, not building a worker framework. The generated worker template has TODO comments where developers implement their actual logic.

This feels like the right balance - smooth the communication boundary without becoming a background job system.