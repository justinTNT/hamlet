# Proposal: Hamlet-Edge (F# on Cloudflare)

## The Core Thesis

Hamlet is a **product line**, not a single product.

The pinnacle product needs Node.js for realtime features (SSE, WebSockets). But should it be **Elm + Node** or **Fable + Node**? That's undecided.

**Hamlet-Edge** is a Cloudflare-first fork to explore F#/Fable in a constrained environment — without the complexity of concurrency, persistent connections, or app-specific workflows. Workers force simplicity: no SSE, no WebSockets, limited CPU time. A good place to feel out the language.

If Fable works well on the edge, it might become the Node target too. If not, we've learned something without derailing the main product.

---

## Why Cloudflare First?

| Concern | Node (Current) | Workers (Fork) |
| :--- | :--- | :--- |
| **SSE / WebSockets** | Native support | Not available — forces simpler patterns |
| **Database** | Postgres via `pg` | D1 or Hyperdrive — forces simpler queries |
| **Concurrency** | Full async complexity | Single-threaded, short-lived — no rabbit holes |
| **Deployment** | Docker / VPS / Fly | `wrangler deploy` — global in seconds |
| **Complexity** | Real-world messiness | Constrained by design |

The strictness of Workers is the point. Learn F# where it can't get complicated. If it feels good there, bring it to Node with confidence.

---

## The Rosetta Stone: Hamlet vs. Fable

| Concept | Hamlet (Current) | Fable (Proposed) | Benefit |
| :--- | :--- | :--- | :--- |
| **Shared Types** | `buildamp gen` (Elm Type -> Tree-sitter -> JS) | `Shared.fs` | No generation step. Compiler guarantees sync. |
| **API Definition** | `schema.elm` + `api.js` | `type IApi = { ... }` | Interface *is* the definition. |
| **Client Fetch** | `Api.Generated.elm` (Autogenerated) | `Fable.Remoting.Client` | Auto-generated proxy from the type. |
| **Server Logic** | `elm-node` (Worker thread) | `Server.fs` -> JS | Runs on main thread. No serialization cost. |
| **Database** | `ports` + `elm-service.js` (Generic SQL) | Direct SQL Driver | Full SQL power, no intermediate "Query Object". |
| **Runtime** | `ProjectLoader` (Custom Routing) | `Cloudflare Worker` (Standard) | deploy `wrangler`. Done. |

---

## Code Comparison

### A. The Setup (The Type)

**Hamlet:**
You write Elm types. BuildAmp parses them with tree-sitter. It generates JS/Elm glue.
```elm
-- Schema.elm
type alias User = { id : String, email : String }
```

**Fable:**
You write F#. You reference the file. Done.
```fsharp
// Shared.fs
namespace Shared

type User = { Id : string; Email : string }

type IApi =
    { getUser : string -> Async<User option>
      updateUser : User -> Async<Result<User, string>> }
```

### B. The Server (The Implementation)

**Hamlet (Elm + JS Glue):**
You need an Elm "Port helper", a JS "Port Handler", and a JS "SQL Runner".

```javascript
// api.js (The Glue)
app.ports.getUser.subscribe(async (id) => {
  const user = await db.query("SELECT * FROM users WHERE id = $1", [id]);
  app.ports.gotUser.send(user);
});
```

```elm
// Backend.elm (The Logic)
update msg model =
    case msg of
        GotUser user -> ...
```

**Fable (Direct Implementation):**
No glue. Just a function.

```fsharp
// Server.fs
let api : IApi = {
    getUser = fun id -> async {
        // Direct DB Access!
        let! users = Db.query "SELECT * FROM users WHERE id = @id" (dict ["id", box id])
        return users |> List.tryHead
    }
    updateUser = ...
}

// The Boilerplate (One time setup)
let webApp =
    Remoting.createApi()
    |> Remoting.fromValue api
    |> Remoting.buildCloudflareWorker
```

### C. The Client (The Usage)

**Hamlet:**
Requires generated `Api.elm` code.

**Fable:**
Uses the shared type definition to create a proxy.

```fsharp
// Client.fs
let api = Remoting.createApi<IApi>()

let update msg model =
    match msg with
    | LoadUser id ->
        model, Cmd.OfAsync.perform api.getUser id GotUser
```

---

## The "Gotchas" (Trade-offs)

### A. It's not Elm.
F# is 95% similar to Elm, but it allows:
- **Nulls**: (via interop). You have to be careful at the edges.
- **Exceptions**: `failwith "error"` crashes the request. Elm forces `Result`.
- **Mutation**: It's available (`let mutable x = 1`). Discipline required.

### B. The Ecosystem Split
In Elm, there is generally "The Elm Way".
In F#, you have choices:
- UI: `Feliz` (React-style DSL) vs `Sutil` (Pure reactive).
- JSON: `Thoth.Json` (Manual decoders like Elm) vs `Fable.SimpleJson` (Auto).

### C. Cloudflare Specifics
Fable compiles to JS.
- **Good**: It runs natively on Workers. Small bundles = fast cold starts.
- **Bad**: You can't use *all* .NET libraries. Only Fable-compatible or JS interop.
- **Example**: No `System.Data.SqlClient`. Must use D1 bindings or Hyperdrive.

---

## The Verdict

**Fork Score: 8/10**

Hamlet-Edge is a low-risk way to explore F#:
1. **Constrained environment** — no concurrency rabbit holes, no SSE complexity
2. **Fast iteration** — `wrangler deploy` in seconds, global distribution free
3. **Real products** — simpler offerings ship on Workers while we learn

If Fable proves itself:
- Upgrade path to **Fable + Node** for the pinnacle
- Shared types, shared patterns, one language across the stack

If it doesn't:
- Elm + Node remains solid
- Workers products stay on Fable (it's fine for simple stuff)
- No harm done

---

## When to Fork?

**Now.**

Hamlet is functional but not deep. The hard problems — semantic text anchoring, realtime collaboration — are **pinnacle-specific**, not product-line problems. They can wait.

The product line needs a solid foundation first. Better to test F#/Fable now, while the codebase is simple, than after we're knee-deep in complexity.

**The plan:**
- **Hamlet**: simmer. Maintenance mode. It works.
- **Hamlet-Edge**: sprint. Rebuild the foundation in Fable on Cloudflare.
- **Pinnacle**: later. Attack the hard problems once the language question is settled.

If Fable proves itself on the edge, we bring it to Node with confidence. If not, we return to Elm knowing we made the right choice.

Simplicity compounds.
