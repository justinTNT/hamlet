# Missing Generation Pieces

**STATUS**: Implementation tasks to complete "Rust once, JSON never" vision

**PRIORITY**: High (core framework gaps)

## Overview

Core generation features that are missing from the existing framework. These are straightforward implementation tasks with clear requirements.

## 0. Directory Restructure & Sensible Defaults (Prerequisite)

**Current Problem**: Mixed database and API models under `src/models/domain/` make generation logic unclear. Repetitive boilerplate derives everywhere.

**Solution**: Reorganize by responsibility following "directory structure determines behavior" principle + automatic sensible defaults:

```
src/models/
├── db/          # Database models → generate SQL queries (no macro needed)
├── api/         # API models → generate Express routes (#[buildamp_api] with parameters)
├── storage/     # Browser localStorage → generate client storage APIs  
├── kv/          # Server KV store → generate KV store APIs (new directory)
└── events/      # SSE events → generate event handling
```

**Auto-Generated Derives by Directory**:
```rust
// All models automatically get sensible defaults:
// Clone, Serialize, Deserialize + Debug (in development)

// OLD: Manual boilerplate everywhere
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPreferences { ... }

// NEW: Automatic based on directory location
pub struct UserPreferences { ... }  // Auto-gets Clone, Serialize, Deserialize, Debug
```

**Directory-Specific Auto-Derives**:
- `models/storage/` → `Clone, Serialize, Deserialize, Debug`
- `models/kv/` → `Clone, Serialize, Deserialize, Debug`  
- `models/db/` → `Clone, Serialize, Deserialize, Debug` + database traits
- `models/api/` → `Clone, Serialize, Deserialize, Debug` + API traits

**Migration**:
- Move `*_db.rs` files to `src/models/db/`
- Move `*_api.rs` files to `src/models/api/`
- Remove redundant `#[buildamp_domain]` macro (implied by `models/db/` location)
- Remove manual `#[derive(...)]` boilerplate (auto-generated by directory)
- Keep `#[buildamp_api(path = "...")]` macro (parameters provide meaningful configuration)
- Simplify storage models (remove over-the-top examples)

**Benefits**: Clear separation of concerns, zero boilerplate derives, directory-driven generation, consistent defaults.

## 1. Query Builders from Rust Models

**Current Problem**: Dangerous SQL string manipulation in `database.js`:
```javascript
// This should not exist - dangerous and error-prone
if (text.includes('WHERE')) {
    text = text.replace('WHERE', 'WHERE host = $1 AND');
}
```

**Solution**: Generate type-safe query functions from database models (directory-based, no macro needed):

```rust
// Input: Database models in src/models/db/
// src/models/db/posts.rs  
pub struct Post {
    pub title: String,
    pub content: String,
    pub author_id: String,
}
```

**Generated Output**:
```javascript
// Auto-generated query functions
function insertPost(post, host) {
    return pool.query(
        'INSERT INTO posts (title, content, author_id, host) VALUES ($1, $2, $3, $4) RETURNING *',
        [post.title, post.content, post.author_id, host]
    );
}

function getPostsByAuthor(authorId, host) {
    return pool.query(
        'SELECT * FROM posts WHERE author_id = $1 AND host = $2',
        [authorId, host]
    );
}

function updatePost(postId, updates, host) {
    // Generated update with proper tenant isolation
}

function deletePost(postId, host) {
    // Generated delete with proper tenant isolation  
}
```

**Benefits**: Eliminates manual SQL, automatic tenant isolation, type-safe from Rust models.

## 2. API Route Generation

**Current Problem**: Missing route generation from `#[buildamp_api]` annotations.

**Solution**: Generate Express routes from API model annotations:

```rust
// Input: API models in src/models/api/
// src/models/api/feed.rs
#[buildamp_api(path = "GetFeed")]
pub struct GetFeedReq {
    #[api(Inject = "host")]
    pub host: String,
    pub page: Option<u32>,
}

pub struct GetFeedRes {
    pub posts: Vec<Post>,
    pub has_more: bool,
}
```

**Generated Output**:
```javascript
// Auto-generated Express route
server.app.post('/api/GetFeed', async (req, res) => {
    try {
        // Inject host from tenant middleware
        const requestData = { ...req.body, host: req.context.host };
        
        // Validate request against Rust types
        const validatedReq = validateGetFeedReq(requestData);
        
        // Call WASM/Elm business logic
        const result = await server.getService('wasm').handle_get_feed_req(validatedReq, req.context);
        
        // Return type-safe response
        res.json(result);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});
```

**Benefits**: Eliminates manual route definitions, automatic validation, type-safe request/response handling.

## 3. Server KV Store Generation

**Current Problem**: Hardcoded generic KV REST endpoints in `key-value-store.js`:
```javascript
// Generic endpoints that should be type-specific
server.app.post('/kv/:type/:key', (req, res) => {
    const { type, key } = req.params;
    // Generic handling, no type safety
});
```

**Solution**: Generate KV interfaces from models in `src/models/kv/` (directory-based, no macro needed):

```rust
// Input: Server KV models in src/models/kv/
// src/models/kv/user_sessions.rs
pub struct UserSession {
    pub user_id: String,
    pub login_time: i64,
    pub permissions: Vec<String>,
    pub ttl: u32, // TTL in seconds
}

// src/models/kv/game_state.rs
pub struct GameState {
    pub game_id: String,
    pub players: Vec<Player>,
    pub board_state: BoardData,
    pub ttl: u32, // TTL in seconds
}
```

**Generated Output**:
```javascript
// Type-safe KV functions from user_sessions.rs
async function setUserSession(sessionId, session, host) {
    return await kvStore.set(`user_session:${host}:${sessionId}`, session, session.ttl);
}

async function getUserSession(sessionId, host) {
    return await kvStore.get(`user_session:${host}:${sessionId}`);
}

// Type-safe KV functions from game_state.rs
async function setGameState(gameId, state, host) {
    return await kvStore.set(`game_state:${host}:${gameId}`, state, state.ttl);
}

async function getGameState(gameId, host) {
    return await kvStore.get(`game_state:${host}:${gameId}`);
}
```

**Benefits**: Type-safe KV operations, automatic key namespacing, TTL from model definitions, tenant isolation.

## 4. Browser Storage Generation (ESSENTIAL)

**Core Problem**: Elm cannot directly access localStorage - needs manual JavaScript interface layer.

**Hamlet's Mission**: Eliminate ALL manual JavaScript interfaces. This is precisely what Hamlet exists to solve.

**Current Situation**: Storage models exist in `src/models/storage/` but no generation, forcing manual JS interfaces.

**Solution**: Generate type-safe browser storage APIs AND Elm ports from storage models:

```rust
// Input: Browser storage models in src/models/storage/
// src/models/storage/user_storage.rs (simplified, auto-derives)
pub struct UserPreferences {
    pub theme: String,
    pub notifications: bool,
    pub language: String,
}

pub struct AuthState {
    pub user_id: String,
    pub session_token: String,
    pub expires_at: i64,
    pub permissions: Vec<String>,
}

// src/models/storage/ui_storage.rs (simplified, auto-derives)
pub struct ViewportState {
    pub scroll_y: f64,
    pub selected_item: Option<String>,
    pub sidebar_collapsed: bool,
}
```

**Generated JavaScript APIs**:
```javascript
// Auto-generated browser storage APIs
class UserPreferencesStorage {
    static save(preferences) {
        localStorage.setItem('user_preferences', JSON.stringify(preferences));
        // Notify Elm of change
        app.ports.userPreferencesChanged.send(preferences);
    }
    
    static load() {
        const data = localStorage.getItem('user_preferences');
        return data ? JSON.parse(data) : null;
    }
    
    static clear() {
        localStorage.removeItem('user_preferences');
        app.ports.userPreferencesChanged.send(null);
    }
}

// Elm port subscriptions automatically wired
app.ports.saveUserPreferences.subscribe(UserPreferencesStorage.save);
app.ports.loadUserPreferences.subscribe(() => {
    const prefs = UserPreferencesStorage.load();
    app.ports.userPreferencesLoaded.send(prefs);
});
```

**Generated Elm Ports** (auto-added to main Elm module):
```elm
-- Auto-generated from UserPreferences storage model
port saveUserPreferences : UserPreferences -> Cmd msg
port loadUserPreferences : () -> Cmd msg
port userPreferencesLoaded : (Maybe UserPreferences -> msg) -> Sub msg
port userPreferencesChanged : (Maybe UserPreferences -> msg) -> Sub msg

-- Auto-generated from FormDraft storage model
port saveFormDraft : FormDraft -> Cmd msg
port loadFormDraft : String -> Cmd msg  -- formId parameter
port formDraftLoaded : (Maybe FormDraft -> msg) -> Sub msg
```

**Generated Elm Helper Functions**:
```elm
-- Auto-generated storage helpers
module Storage.UserPreferences exposing (save, load, subscribe)

save : UserPreferences -> Cmd msg
save prefs = saveUserPreferences prefs

load : Cmd msg  
load = loadUserPreferences ()

subscribe : (Maybe UserPreferences -> msg) -> Sub msg
subscribe toMsg = userPreferencesLoaded toMsg
```

**Benefits**: 
- **Zero manual JavaScript** for storage
- **Direct Elm-to-storage** communication  
- **Type-safe** across Rust → JS → Elm boundary
- **Automatic port wiring** and change notifications
- **Consistent patterns** across all storage models

This completes Hamlet's core mission: "Rust once, JSON never" extends to browser storage.

## Implementation Notes

### Directory-Driven Generation
- **`src/models/db/`** → Database query functions (no macro needed)
- **`src/models/api/`** → Express routes (keep `#[buildamp_api]` for parameters)  
- **`src/models/kv/`** → Server KV store functions (no macro needed)
- **`src/models/storage/`** → Browser storage APIs (no macro needed)
- **`src/models/events/`** → SSE event handling (existing)

### Query Builders
- Generate from models in `src/models/db/`
- Include common operations: insert, select, update, delete
- Automatic tenant isolation via host parameter
- Replace string manipulation in `database.js` middleware

### API Routes  
- Generate from `#[buildamp_api]` annotations in `src/models/api/`
- Include request validation and context injection
- Integrate with existing WASM/Elm business logic
- Replace manual route definitions

### KV Store Functions
- Generate from models in `src/models/kv/`
- Type-specific access functions with TTL support
- Automatic key namespacing and tenant isolation
- Replace generic REST endpoints

### Browser Storage APIs
- Generate from models in `src/models/storage/`
- localStorage/sessionStorage wrapper classes
- Type-safe serialization and deserialization
- Consistent naming and error handling

## Dependencies

All pieces build on existing infrastructure:
- Database connection pooling (existing)
- Tenant isolation middleware (existing) 
- Session management (existing)
- Type generation system (existing)
- Existing storage models (ready for generation)

These are **completion tasks** for partially implemented features, not new architecture.

## Implementation Order

1. **Directory Restructure** → Clean foundation
2. **Database Query Generation** → Eliminate dangerous SQL strings  
3. **API Route Generation** → Complete existing macro functionality
4. **Browser Storage Generation** → ESSENTIAL - Enable direct Elm-to-storage (core Hamlet mission)
5. **KV Store Generation** → Add missing server-side storage

**Priority Rationale**: Browser storage generation is core to Hamlet's mission of eliminating manual JavaScript interfaces. This enables Elm to work directly with browser storage through auto-generated, type-safe ports.