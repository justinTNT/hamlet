/**
 * Database Query Generation V2
 * Updated to output to .hamlet-gen directories
 */

import fs from 'fs';
import path from 'path';
import { getGenerationPaths, checkLegacyFiles } from './paths.js';
import { parseRustDbModels } from './parse_rust_models.js';

/**
 * Generate Database.js with all database functions
 */
export async function generateDatabaseQueries(config = {}) {
    console.log('ðŸ” Parsing Rust database models...');
    
    const paths = getGenerationPaths();
    checkLegacyFiles(paths);
    
    const dbModelsPath = config.inputBasePath || paths.dbModelsDir;
    const outputPath = config.jsOutputPath || paths.jsGlueDir;
    
    if (!fs.existsSync(dbModelsPath)) {
        console.log(`ðŸ“ No database models found at ${dbModelsPath}, skipping database query generation`);
        return;
    }
    
    // Parse models
    const allStructs = parseRustDbModels(dbModelsPath);
    
    if (allStructs.length === 0) {
        console.log('âš ï¸  No database models found');
        return;
    }
    
    console.log(`ðŸ“Š Found ${allStructs.length} database models`);
    
    // Generate the Database.js file
    const outputFile = path.join(outputPath, 'Database.js');
    const code = generateDatabaseCode(allStructs);
    
    fs.writeFileSync(outputFile, code);
    console.log(`âœ… Generated ${outputFile}`);
    
    return {
        structs: allStructs.length,
        functions: allStructs.length * 5, // CRUD operations per model
        outputFile
    };
}

/**
 * Generate the Database.js code
 */
function generateDatabaseCode(structs) {
    const imports = `/**
 * Generated Database Queries
 * Generated from: .hamlet-gen/contracts.json
 * DO NOT EDIT - This file is automatically generated from Rust models
 */

import { createClient } from '@libsql/client';

// Initialize database client
let db = null;

export function initDatabase(config) {
    db = createClient(config);
    return db;
}

export function getDatabase() {
    if (!db) {
        throw new Error('Database not initialized. Call initDatabase() first.');
    }
    return db;
}
`;

    const functions = structs.map(struct => generateStructFunctions(struct)).join('\n\n');
    
    return imports + '\n' + functions;
}

/**
 * Generate CRUD functions for a struct
 */
function generateStructFunctions(struct) {
    const { name, tableName, fields } = struct;
    const primaryKey = fields.find(f => f.isPrimaryKey) || fields[0];
    
    return `
// ${name} CRUD operations

export async function create${name}(data) {
    const columns = [${fields.filter(f => !f.isPrimaryKey).map(f => `'${f.name}'`).join(', ')}];
    const placeholders = columns.map(() => '?').join(', ');
    const values = [${fields.filter(f => !f.isPrimaryKey).map(f => `data.${f.name}`).join(', ')}];
    
    const query = \`INSERT INTO ${tableName} (\${columns.join(', ')}) VALUES (\${placeholders})\`;
    const result = await db.execute({
        sql: query,
        args: values
    });
    
    return result.lastInsertRowid;
}

export async function get${name}(id) {
    const result = await db.execute({
        sql: \`SELECT * FROM ${tableName} WHERE ${primaryKey.name} = ?\`,
        args: [id]
    });
    
    return result.rows[0] || null;
}

export async function update${name}(id, data) {
    const updates = [];
    const values = [];
    
    ${fields.filter(f => !f.isPrimaryKey).map(f => `
    if (data.${f.name} !== undefined) {
        updates.push('${f.name} = ?');
        values.push(data.${f.name});
    }`).join('')}
    
    if (updates.length === 0) {
        return false;
    }
    
    values.push(id);
    const query = \`UPDATE ${tableName} SET \${updates.join(', ')} WHERE ${primaryKey.name} = ?\`;
    
    const result = await db.execute({
        sql: query,
        args: values
    });
    
    return result.rowsAffected > 0;
}

export async function delete${name}(id) {
    const result = await db.execute({
        sql: \`DELETE FROM ${tableName} WHERE ${primaryKey.name} = ?\`,
        args: [id]
    });
    
    return result.rowsAffected > 0;
}

export async function list${name}s(options = {}) {
    const { limit = 100, offset = 0, orderBy = '${primaryKey.name}', orderDir = 'ASC' } = options;
    
    const result = await db.execute({
        sql: \`SELECT * FROM ${tableName} ORDER BY \${orderBy} \${orderDir} LIMIT ? OFFSET ?\`,
        args: [limit, offset]
    });
    
    return result.rows;
}`;
}

export default generateDatabaseQueries;