/**
 * Auto-Generated Database Query Functions
 * Generated from database models
 * 
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * ⚠️  Changes will be overwritten during next generation
 * 
 * This file replaces dangerous SQL string manipulation with type-safe,
 * pre-validated database queries that include automatic tenant isolation.
 */

// Factory function that takes a pool and returns bound query functions
export default function createDbQueries(pool) {
// Auto-generated database functions for Guest

/**
 * Insert Guest with automatic tenant isolation
 */
async function insertGuest(guest, host) {
    const result = await pool.query(
        'INSERT INTO guest (name, picture, session_id, created_at, host) VALUES ($2, $3, $4, $5, $1) RETURNING *',
        [host, guest.name, guest.picture, guest.session_id, guest.created_at]
    );
    return result.rows[0];
}

/**
 * Create Guest (alias for insert)
 */
async function createGuest(data) {
    const { host, ...rest } = data;
    return insertGuest(rest, host);
}

/**
 * Get all Guests for a tenant (includes soft-deleted)
 */
async function getGuestsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM guest WHERE host = $1 ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Find all live Guests for a tenant (excludes soft-deleted)
 */
async function findGuestsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM guest WHERE host = $1 AND deleted_at IS NULL ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get Guest by ID with tenant isolation (includes soft-deleted)
 */
async function getGuestById(id, host) {
    const result = await pool.query(
        'SELECT * FROM guest WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Find Guest by ID with tenant isolation (excludes soft-deleted)
 */
async function findGuestById(id, host) {
    const result = await pool.query(
        'SELECT * FROM guest WHERE id = $1 AND host = $2 AND deleted_at IS NULL',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update Guest with tenant isolation
 */
async function updateGuest(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);

    if (setClause === '') {
        return getGuestById(id, host);
    }

    const sql = 'UPDATE guest SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Soft delete Guest (sets deleted_at timestamp)
 */
async function killGuest(id, host) {
    const result = await pool.query(
        'UPDATE guest SET deleted_at = NOW() WHERE id = $1 AND host = $2 RETURNING *',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Hard delete Guest with tenant isolation
 */
async function deleteGuest(id, host) {
    const result = await pool.query(
        'DELETE FROM guest WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

// Auto-generated database functions for ItemComment

/**
 * Insert ItemComment with automatic tenant isolation
 */
async function insertItemComment(itemcomment, host) {
    const result = await pool.query(
        'INSERT INTO item_comment (item_id, guest_id, parent_id, author_name, text, created_at, host) VALUES ($2, $3, $4, $5, $6, $7, $1) RETURNING *',
        [host, itemcomment.item_id, itemcomment.guest_id, itemcomment.parent_id, itemcomment.author_name, itemcomment.text, itemcomment.created_at]
    );
    return result.rows[0];
}

/**
 * Create ItemComment (alias for insert)
 */
async function createItemComment(data) {
    const { host, ...rest } = data;
    return insertItemComment(rest, host);
}

/**
 * Get all ItemComments for a tenant (includes soft-deleted)
 */
async function getItemCommentsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM item_comment WHERE host = $1 ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Find all live ItemComments for a tenant (excludes soft-deleted)
 */
async function findItemCommentsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM item_comment WHERE host = $1 AND deleted_at IS NULL ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get ItemComment by ID with tenant isolation (includes soft-deleted)
 */
async function getItemCommentById(id, host) {
    const result = await pool.query(
        'SELECT * FROM item_comment WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Find ItemComment by ID with tenant isolation (excludes soft-deleted)
 */
async function findItemCommentById(id, host) {
    const result = await pool.query(
        'SELECT * FROM item_comment WHERE id = $1 AND host = $2 AND deleted_at IS NULL',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update ItemComment with tenant isolation
 */
async function updateItemComment(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);

    if (setClause === '') {
        return getItemCommentById(id, host);
    }

    const sql = 'UPDATE item_comment SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Soft delete ItemComment (sets deleted_at timestamp)
 */
async function killItemComment(id, host) {
    const result = await pool.query(
        'UPDATE item_comment SET deleted_at = NOW() WHERE id = $1 AND host = $2 RETURNING *',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Hard delete ItemComment with tenant isolation
 */
async function deleteItemComment(id, host) {
    const result = await pool.query(
        'DELETE FROM item_comment WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

// Auto-generated database functions for ItemTag

/**
 * Insert ItemTag with automatic tenant isolation
 */
async function insertItemTag(itemtag, host) {
    const result = await pool.query(
        'INSERT INTO item_tag (item_id, tag_id, host) VALUES ($2, $3, $1) RETURNING *',
        [host, itemtag.item_id, itemtag.tag_id]
    );
    return result.rows[0];
}

/**
 * Create ItemTag (alias for insert)
 */
async function createItemTag(data) {
    const { host, ...rest } = data;
    return insertItemTag(rest, host);
}

/**
 * Get all ItemTags for a tenant (includes soft-deleted)
 */
async function getItemTagsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM item_tag WHERE host = $1 ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Find all live ItemTags for a tenant (excludes soft-deleted)
 */
async function findItemTagsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM item_tag WHERE host = $1 AND deleted_at IS NULL ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get ItemTag by ID with tenant isolation (includes soft-deleted)
 */
async function getItemTagById(id, host) {
    const result = await pool.query(
        'SELECT * FROM item_tag WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Find ItemTag by ID with tenant isolation (excludes soft-deleted)
 */
async function findItemTagById(id, host) {
    const result = await pool.query(
        'SELECT * FROM item_tag WHERE id = $1 AND host = $2 AND deleted_at IS NULL',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update ItemTag with tenant isolation
 */
async function updateItemTag(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);

    if (setClause === '') {
        return getItemTagById(id, host);
    }

    const sql = 'UPDATE item_tag SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Soft delete ItemTag (sets deleted_at timestamp)
 */
async function killItemTag(id, host) {
    const result = await pool.query(
        'UPDATE item_tag SET deleted_at = NOW() WHERE id = $1 AND host = $2 RETURNING *',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Hard delete ItemTag with tenant isolation
 */
async function deleteItemTag(id, host) {
    const result = await pool.query(
        'DELETE FROM item_tag WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

// Auto-generated database functions for MicroblogItem

/**
 * Insert MicroblogItem with automatic tenant isolation
 */
async function insertMicroblogItem(microblogitem, host) {
    const result = await pool.query(
        'INSERT INTO microblog_item (title, link, image, extract, owner_comment, created_at, view_count, host) VALUES ($2, $3, $4, $5, $6, $7, $8, $1) RETURNING *',
        [host, microblogitem.title, microblogitem.link, microblogitem.image, microblogitem.extract, microblogitem.owner_comment, microblogitem.created_at, microblogitem.view_count]
    );
    return result.rows[0];
}

/**
 * Create MicroblogItem (alias for insert)
 */
async function createMicroblogItem(data) {
    const { host, ...rest } = data;
    return insertMicroblogItem(rest, host);
}

/**
 * Get all MicroblogItems for a tenant (includes soft-deleted)
 */
async function getMicroblogItemsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM microblog_item WHERE host = $1 ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Find all live MicroblogItems for a tenant (excludes soft-deleted)
 */
async function findMicroblogItemsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM microblog_item WHERE host = $1 AND deleted_at IS NULL ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get MicroblogItem by ID with tenant isolation (includes soft-deleted)
 */
async function getMicroblogItemById(id, host) {
    const result = await pool.query(
        'SELECT * FROM microblog_item WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Find MicroblogItem by ID with tenant isolation (excludes soft-deleted)
 */
async function findMicroblogItemById(id, host) {
    const result = await pool.query(
        'SELECT * FROM microblog_item WHERE id = $1 AND host = $2 AND deleted_at IS NULL',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update MicroblogItem with tenant isolation
 */
async function updateMicroblogItem(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);

    if (setClause === '') {
        return getMicroblogItemById(id, host);
    }

    const sql = 'UPDATE microblog_item SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Soft delete MicroblogItem (sets deleted_at timestamp)
 */
async function killMicroblogItem(id, host) {
    const result = await pool.query(
        'UPDATE microblog_item SET deleted_at = NOW() WHERE id = $1 AND host = $2 RETURNING *',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Hard delete MicroblogItem with tenant isolation
 */
async function deleteMicroblogItem(id, host) {
    const result = await pool.query(
        'DELETE FROM microblog_item WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

// Auto-generated database functions for Tag

/**
 * Insert Tag with automatic tenant isolation
 */
async function insertTag(tag, host) {
    const result = await pool.query(
        'INSERT INTO tag (name, host) VALUES ($2, $1) RETURNING *',
        [host, tag.name]
    );
    return result.rows[0];
}

/**
 * Create Tag (alias for insert)
 */
async function createTag(data) {
    const { host, ...rest } = data;
    return insertTag(rest, host);
}

/**
 * Get all Tags for a tenant (includes soft-deleted)
 */
async function getTagsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM tag WHERE host = $1 ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Find all live Tags for a tenant (excludes soft-deleted)
 */
async function findTagsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM tag WHERE host = $1 AND deleted_at IS NULL ORDER BY created_at DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get Tag by ID with tenant isolation (includes soft-deleted)
 */
async function getTagById(id, host) {
    const result = await pool.query(
        'SELECT * FROM tag WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Find Tag by ID with tenant isolation (excludes soft-deleted)
 */
async function findTagById(id, host) {
    const result = await pool.query(
        'SELECT * FROM tag WHERE id = $1 AND host = $2 AND deleted_at IS NULL',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update Tag with tenant isolation
 */
async function updateTag(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);

    if (setClause === '') {
        return getTagById(id, host);
    }

    const sql = 'UPDATE tag SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Soft delete Tag (sets deleted_at timestamp)
 */
async function killTag(id, host) {
    const result = await pool.query(
        'UPDATE tag SET deleted_at = NOW() WHERE id = $1 AND host = $2 RETURNING *',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Hard delete Tag with tenant isolation
 */
async function deleteTag(id, host) {
    const result = await pool.query(
        'DELETE FROM tag WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

    // Return all functions bound to the pool
    return {
        insertGuest,
        createGuest,
        getGuestsByHost,
        findGuestsByHost,
        getGuestById,
        findGuestById,
        updateGuest,
        killGuest,
        deleteGuest,
        insertItemComment,
        createItemComment,
        getItemCommentsByHost,
        findItemCommentsByHost,
        getItemCommentById,
        findItemCommentById,
        updateItemComment,
        killItemComment,
        deleteItemComment,
        insertItemTag,
        createItemTag,
        getItemTagsByHost,
        findItemTagsByHost,
        getItemTagById,
        findItemTagById,
        updateItemTag,
        killItemTag,
        deleteItemTag,
        insertMicroblogItem,
        createMicroblogItem,
        getMicroblogItemsByHost,
        findMicroblogItemsByHost,
        getMicroblogItemById,
        findMicroblogItemById,
        updateMicroblogItem,
        killMicroblogItem,
        deleteMicroblogItem,
        insertTag,
        createTag,
        getTagsByHost,
        findTagsByHost,
        getTagById,
        findTagById,
        updateTag,
        killTag,
        deleteTag
    };
}
