port module Api.Handlers.GetFeedHandlerTEA exposing (main)

{-| GetFeed Handler - TEA Architecture

This handler implements The Elm Architecture pattern for async request processing.
It demonstrates the req + state + stage pattern for complex async operations.

Business Logic:
TODO: Customize the stages and business logic for your specific GetFeed endpoint
TODO: Add database queries and external service calls as needed
TODO: Implement proper error handling and validation

-}

import Api.Backend exposing (GetFeedReq, GetFeedRes)
import Generated.Database as DB
import Generated.Events as Events
import Generated.Services as Services
import Json.Encode as Encode
import Json.Decode as Decode
import Platform
import Task


-- MODEL (req + state + stage)

type alias Model =
    { stage : Stage
    , request : Maybe GetFeedReq
    , context : Maybe Context
    , globalConfig : GlobalConfig
    , globalState : GlobalState
    , loadedItems : List DB.MicroblogItemDb
    , allTags : List DB.TagDb  -- All tags loaded upfront
    , itemTags : List DB.ItemTagDb -- item_id to tag_id mappings  
    , loadedComments : List DB.ItemCommentDb
    }


type Stage
    = Idle
    | LoadingAllTags
    | LoadingItems
    | LoadingItemTags
    | LoadingComments
    | Complete GetFeedRes
    | Failed String


type alias Context =
    { host : String
    , sessionId : Maybe String
    }


type alias GlobalConfig = DB.GlobalConfig  -- Server-issued read-only config


type alias GlobalState = DB.GlobalState  -- Mutable handler state


-- UPDATE

type Msg
    = HandleRequest RequestBundle
    | AllTagsLoaded DB.DbResponse
    | ItemsLoaded DB.DbResponse
    | ItemTagsLoaded DB.DbResponse
    | CommentsLoaded DB.DbResponse


type alias RequestBundle =
    { id : String
    , context : Context
    , request : GetFeedReq
    }


init : Flags -> ( Model, Cmd Msg )
init flags =
    ( { stage = Idle
      , request = Nothing
      , context = Nothing
      , globalConfig = flags.globalConfig
      , globalState = flags.globalState
      , loadedItems = []
      , allTags = []
      , itemTags = []
      , loadedComments = []
      }
    , Cmd.none
    )


type alias Flags =
    { globalConfig : GlobalConfig
    , globalState : GlobalState
    }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        HandleRequest bundle ->
            ( { model 
              | stage = LoadingAllTags
              , request = Just bundle.request
              , context = Just bundle.context
              , loadedItems = []
              , allTags = []
              , itemTags = []
              , loadedComments = []
              }
            , loadAllTags
            )
        
        AllTagsLoaded result ->
            if model.stage == LoadingAllTags then
                case handleDbResponse result of
                    Ok data ->
                        let
                            _ = Debug.log "ðŸ·ï¸  Raw tags data ;)" data
                        in
                        case decodeAllTags data of
                            Ok tags ->
                                let
                                    _ = Debug.log "ðŸ·ï¸  Decoded tags ;)" tags
                                in
                                ( { model 
                                  | stage = LoadingItems
                                  , allTags = tags 
                                  }
                                , loadMicroblogItems
                                )
                            Err error ->
                                ( { model | stage = Failed error }
                                , complete (encodeError error)
                                )
                    Err error ->
                        ( { model | stage = Failed error }
                        , complete (encodeError error)
                        )
            else
                ( model, Cmd.none )
        
        ItemsLoaded result ->
            if model.stage == LoadingItems then
                case handleDbResponse result of
                    Ok data ->
                        let
                            _ = Debug.log "ðŸ“„ Raw items data" data
                        in
                        case decodeItems data of
                            Ok items ->
                                let
                                    itemIds = List.map .id items
                                    _ = Debug.log "ðŸ“„ Decoded items" items
                                    _ = Debug.log "ðŸ“„ Item IDs" itemIds
                                in
                                ( { model 
                                  | stage = LoadingItemTags
                                  , loadedItems = items 
                                  }
                                , loadItemTagsForItems itemIds
                                )
                            Err error ->
                                ( { model | stage = Failed error }
                                , complete (encodeError error)
                                )
                    Err error ->
                        ( { model | stage = Failed error }
                        , complete (encodeError error)
                        )
            else
                ( model, Cmd.none )
        
        ItemTagsLoaded result ->
            if model.stage == LoadingItemTags then
                case handleDbResponse result of
                    Ok data ->
                        let
                            _ = Debug.log "ðŸ”— Raw item-tags data" data
                        in
                        case decodeItemTags data of
                            Ok itemTagsList ->
                                let
                                    itemIds = List.map .id model.loadedItems
                                    _ = Debug.log "ðŸ”— Decoded item-tags" itemTagsList
                                in
                                ( { model 
                                  | stage = LoadingComments
                                  , itemTags = itemTagsList 
                                  }
                                , loadCommentsForItems itemIds
                                )
                            Err error ->
                                ( { model | stage = Failed error }
                                , complete (encodeError error)
                                )
                    Err error ->
                        ( { model | stage = Failed error }
                        , complete (encodeError error)
                        )
            else
                ( model, Cmd.none )
        
        CommentsLoaded result ->
            if model.stage == LoadingComments then
                case handleDbResponse result of
                    Ok data ->
                        case decodeComments data of
                            Ok comments ->
                                let feedItems = transformToApiWithRelations model.loadedItems model.allTags model.itemTags comments
                                in
                                ( { model | stage = Complete { items = feedItems } }
                                , complete (encodeGetFeedRes { items = feedItems })
                                )
                            Err error ->
                                ( { model | stage = Failed error }
                                , complete (encodeError error)
                                )
                    Err error ->
                        ( { model | stage = Failed error }
                        , complete (encodeError error)
                        )
            else
                ( model, Cmd.none )


-- BUSINESS LOGIC

{-| Load all tags upfront (there won't be many)
-}
loadAllTags : Cmd Msg
loadAllTags =
    DB.findTags DB.queryAll


{-| Load all microblog items, sorted by creation date (newest first)
-}
loadMicroblogItems : Cmd Msg  
loadMicroblogItems =
    DB.findMicroblogItems (DB.queryAll |> DB.sortByCreatedAt)


{-| Load item-tag relationships for specific item IDs
-}
loadItemTagsForItems : List String -> Cmd Msg
loadItemTagsForItems itemIds =
    -- Query item_tags junction table for the given item IDs
    -- For now, query all item_tags (would be optimized with filters in production)
    DB.findItemTags DB.queryAll


{-| Load comments for specific item IDs
-}  
loadCommentsForItems : List String -> Cmd Msg
loadCommentsForItems itemIds =
    -- Query for all comments where item_id is in our list of item IDs
    -- For now, we'll query all comments and filter later
    DB.findItemComments DB.queryAll


{-| Handle database response with error checking
-}
handleDbResponse : DB.DbResponse -> Result String Encode.Value
handleDbResponse response =
    if response.success then
        case response.data of
            Just data -> Ok data
            Nothing -> Err "No data returned from database"
    else
        Err (response.error |> Maybe.withDefault "Database query failed")


{-| Decode all tags
-}
decodeAllTags : Encode.Value -> Result String (List DB.TagDb)
decodeAllTags data =
    case Decode.decodeValue (Decode.list DB.tagDbDecoder) data of
        Ok tags -> Ok tags
        Err error -> Err ("Failed to decode tags: " ++ Decode.errorToString error)


{-| Decode list of MicroblogItemDb from JSON
-}
decodeItems : Encode.Value -> Result String (List DB.MicroblogItemDb)
decodeItems data =
    case Decode.decodeValue (Decode.list microblogItemDbDecoder) data of
        Ok items -> Ok items
        Err error -> Err ("Failed to decode items: " ++ Decode.errorToString error)


{-| Decode item-tag junction table data
-}
decodeItemTags : Encode.Value -> Result String (List DB.ItemTagDb)
decodeItemTags data =
    case Decode.decodeValue (Decode.list DB.itemtagDbDecoder) data of
        Ok itemTags -> Ok itemTags
        Err error -> Err ("Failed to decode item tags: " ++ Decode.errorToString error)


{-| Decode comments from JSON
-}
decodeComments : Encode.Value -> Result String (List DB.ItemCommentDb)
decodeComments data =
    case Decode.decodeValue (Decode.list DB.itemcommentDbDecoder) data of
        Ok comments -> Ok comments
        Err error -> Err ("Failed to decode comments: " ++ Decode.errorToString error)


{-| Transform items with their related data to API format
-}
transformToApiWithRelations : List DB.MicroblogItemDb -> List DB.TagDb -> List DB.ItemTagDb -> List DB.ItemCommentDb -> List Api.Backend.FeedItem
transformToApiWithRelations items allTags itemTags comments =
    List.map (transformDbItemToApiWithRelations allTags itemTags comments) items


{-| Transform a single item with its related data to FeedItem format
-}  
transformDbItemToApiWithRelations : List DB.TagDb -> List DB.ItemTagDb -> List DB.ItemCommentDb -> DB.MicroblogItemDb -> Api.Backend.FeedItem
transformDbItemToApiWithRelations allTags itemTags comments dbItem =
    { id = dbItem.id
    , title = dbItem.data.title
    , image = dbItem.data.image
    , extract = dbItem.data.extract
    , ownerComment = dbItem.data.ownerComment
    , timestamp = dbItem.createdAt
    }




{-| Custom decoder for MicroblogItemDb that handles bigint timestamps as strings
-}
microblogItemDbDecoder : Decode.Decoder DB.MicroblogItemDb
microblogItemDbDecoder =
    Decode.succeed DB.MicroblogItemDb
        |> andMap (Decode.field "id" Decode.string)
        |> andMap (Decode.field "data" DB.microblogitemdataDbDecoder)
        |> andMap (Decode.field "created_at" timestampDecoder)
        |> andMap (Decode.field "view_count" Decode.int)


{-| Decoder that handles timestamps as either strings (from BIGINT) or ints
-}
timestampDecoder : Decode.Decoder Int
timestampDecoder =
    Decode.oneOf
        [ Decode.int
        , Decode.string |> Decode.andThen stringToInt
        ]


stringToInt : String -> Decode.Decoder Int
stringToInt str =
    case String.toInt str of
        Just int -> Decode.succeed int
        Nothing -> Decode.fail ("Could not parse timestamp: " ++ str)


-- Helper for pipeline-style decoding
andMap : Decode.Decoder a -> Decode.Decoder (a -> b) -> Decode.Decoder b
andMap = Decode.map2 (|>)


-- ENCODING

encodeGetFeedRes : GetFeedRes -> Encode.Value
encodeGetFeedRes response =
    Api.Backend.getFeedResEncoder response


encodeError : String -> Encode.Value
encodeError error =
    Encode.object
        [ ("error", Encode.string error)
        ]


-- PORTS (TEA Pattern)

port handleRequest : (RequestBundle -> msg) -> Sub msg
port complete : Encode.Value -> Cmd msg


-- MAIN

main : Program Flags Model Msg
main =
    Platform.worker
        { init = init
        , update = update
        , subscriptions = subscriptions
        }


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch
        [ handleRequest HandleRequest
        , DB.dbResult AllTagsLoaded
        , DB.dbResult ItemsLoaded
        , DB.dbResult ItemTagsLoaded
        , DB.dbResult CommentsLoaded
        ]
