use serde::{Deserialize, Serialize};
use elm_rs::{Elm, ElmDecode, ElmEncode};

/// A database field with a default value that can be omitted on insert
/// Maps to SQL: `field_name TYPE NOT NULL DEFAULT 'default_value'`
/// Default value is specified via type alias for specific use cases
#[derive(Debug, Clone, Serialize, Deserialize, Elm, ElmEncode, ElmDecode)]
#[repr(transparent)]
pub struct DefaultValue<T>(pub T);

/// A database field that is generated by the database (auto-increment, timestamps, etc.)
/// Maps to SQL: `field_name TYPE NOT NULL DEFAULT (expression)` or AUTO_INCREMENT
#[derive(Debug, Clone, Serialize, Deserialize, Elm, ElmEncode, ElmDecode)]
#[repr(transparent)]
pub struct Generated<T>(pub T);

// Implementations for ergonomic usage

impl<T> DefaultValue<T> {
    pub fn new(value: T) -> Self {
        DefaultValue(value)
    }
    
    pub fn get(&self) -> &T {
        &self.0
    }
    
    pub fn into_inner(self) -> T {
        self.0
    }
}

impl<T> Generated<T> {
    pub fn new(value: T) -> Self {
        Generated(value)
    }
    
    pub fn get(&self) -> &T {
        &self.0
    }
    
    pub fn into_inner(self) -> T {
        self.0
    }
}

// Deref implementations for transparent access

impl<T> std::ops::Deref for DefaultValue<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<T> std::ops::Deref for Generated<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

// From implementations for ergonomic construction

impl<T> From<T> for DefaultValue<T> {
    fn from(value: T) -> Self {
        DefaultValue::new(value)
    }
}

impl<T> From<T> for Generated<T> {
    fn from(value: T) -> Self {
        Generated(value)
    }
}

// Type aliases for common database patterns
pub type DatabaseId<T> = Generated<T>;
pub type AutoIncrement<T> = Generated<T>;
pub type Timestamp = Generated<u64>;

// Type aliases for common default values
pub type DefaultComment = DefaultValue<String>;  // For "LGTM" default
pub type DefaultEmpty = DefaultValue<String>;    // For "" default

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_default_field() {
        let field: DefaultValue<String> = DefaultValue::new("custom".to_string());
        assert_eq!(field.get(), "custom");
        
        let field2: DefaultValue<String> = "test".to_string().into();
        assert_eq!(*field2, "test");
    }

    #[test]
    fn test_generated_field() {
        let field: Generated<u64> = Generated::new(12345);
        assert_eq!(field.get(), &12345);
        assert_eq!(*field, 12345);
        
        let timestamp: Timestamp = 1234567890.into();
        assert_eq!(*timestamp, 1234567890);
    }
}