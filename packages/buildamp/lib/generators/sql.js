/**
 * SQL Schema Generation
 *
 * Generates CREATE TABLE statements from Elm schema models.
 * Migrations are hand-written - this only generates schema.sql for fresh installs.
 */

import fs from 'fs';
import path from 'path';
import { getGenerationPaths, ensureOutputDir } from './shared-paths.js';
import { parseElmSchemaDir, parseElmSchemaDirFull } from '../../core/elm-parser-ts.js';

/**
 * Generate CREATE TABLE statement for a struct
 * @param {Object} struct - Parsed struct info
 * @param {string[]} knownTables - All known table names for FK validation
 * @param {Object} unionTypeMap - Map of union type name -> union type info (optional)
 * @returns {{ sql: string, foreignKeys: Array, warnings: Array }}
 */
function generateCreateTable(struct, knownTables = [], unionTypeMap = {}) {
    const { tableName, fields, isMultiTenant, isSoftDelete, multiTenantFieldName } = struct;
    const foreignKeys = [];
    const warnings = [];
    const checkConstraints = [];

    const columnDefs = fields.map(field => {
        const parts = [field.name, field.sqlType];
        parts.push(...field.constraints);

        // Check if field type references an enum-like union type
        const fieldTypeName = field.rustType.replace(/^Maybe\s+/, '').trim();
        if (unionTypeMap[fieldTypeName]) {
            const ut = unionTypeMap[fieldTypeName];
            if (isEnumLike(ut)) {
                const enumValues = ut.variants.map(v => `'${v.name}'`).join(', ');
                checkConstraints.push(`    CHECK (${field.name} IN (${enumValues}))`);
            }
        }

        return '    ' + parts.join(' ');
    });

    // Check what columns already exist in model fields
    const hasHost = fields.some(f => f.name === 'host');

    // Check if model has explicit MultiTenant field
    const hasMultiTenantField = isMultiTenant || fields.some(f => f.isMultiTenant);

    // Only auto-add host if model doesn't have explicit MultiTenant field and doesn't have a host column
    if (!hasMultiTenantField && !hasHost) {
        columnDefs.push('    host TEXT NOT NULL');
    }

    // NOTE: created_at, updated_at, deleted_at are NO LONGER auto-added.
    // Models must explicitly use CreateTimestamp, UpdateTimestamp, or SoftDelete types.

    // Generate foreign key constraints for explicit ForeignKey fields only
    // No auto-detection - only fields typed as ForeignKey get FK constraints
    for (const field of fields) {
        if (!field.isForeignKey) continue;

        if (field.referencedTable) {
            const refTableLower = field.referencedTable.toLowerCase();
            // Prioritize exact matches over fuzzy matches
            const refTable =
                knownTables.find(t => t === refTableLower) ||
                knownTables.find(t => t === refTableLower + 's') ||
                knownTables.find(t => t.endsWith('_' + refTableLower + 's')) ||
                knownTables.find(t => t.endsWith('_' + refTableLower));
            if (refTable) {
                foreignKeys.push({
                    column: field.name,
                    referencedTable: refTable,
                    referencedColumn: 'id'
                });
                columnDefs.push(`    FOREIGN KEY (${field.name}) REFERENCES ${refTable}(id)`);
            } else {
                // ForeignKey declared but table not found - this is an error
                warnings.push(`ERROR: ForeignKey ${field.name} references unknown table: ${field.referencedTable}`);
            }
        }
    }

    // Combine all definitions: columns, foreign keys, and check constraints
    const allDefs = [...columnDefs, ...checkConstraints];

    // Determine the tenant field name for the index (use explicit field name or default to 'host')
    const tenantFieldName = multiTenantFieldName || 'host';

    const sql = `-- Generated from ${struct.filename}
CREATE TABLE ${tableName} (
${allDefs.join(',\n')}
);

-- Index for tenant isolation
CREATE INDEX idx_${tableName}_${tenantFieldName} ON ${tableName}(${tenantFieldName});`;

    return { sql, foreignKeys, warnings };
}

/**
 * Generate full schema.sql from all db models
 * @param {Array} structs - Parsed struct definitions
 * @param {Array} unionTypes - Parsed union type definitions (optional)
 * @returns {{ schema: string, foreignKeys: Array, warnings: Array }}
 */
function generateSchema(structs, unionTypes = []) {
    const header = `-- BuildAmp Generated Schema
-- Generated from database models
--
-- DO NOT EDIT THIS FILE MANUALLY
-- Changes will be overwritten during next generation
--
-- Use this file for fresh database initialization:
--   psql $DATABASE_URL < schema.sql

`;

    // Collect all table names for FK validation
    const knownTables = structs.map(s => s.tableName);

    // Build union type lookup for CHECK constraint generation
    const unionTypeMap = {};
    for (const ut of unionTypes) {
        unionTypeMap[ut.name] = ut;
    }

    // Generate tables with FK validation and CHECK constraints
    const allForeignKeys = [];
    const allWarnings = [];
    const tableSqls = [];

    for (const struct of structs) {
        const result = generateCreateTable(struct, knownTables, unionTypeMap);
        tableSqls.push(result.sql);
        allForeignKeys.push(...result.foreignKeys.map(fk => ({
            table: struct.tableName,
            ...fk
        })));
        allWarnings.push(...result.warnings.map(w => `${struct.tableName}: ${w}`));
    }

    const schema = header + tableSqls.join('\n\n');

    return { schema, foreignKeys: allForeignKeys, warnings: allWarnings };
}

/**
 * Check if a union type is enum-like (all variants have no arguments)
 */
function isEnumLike(unionType) {
    return unionType.variants.every(v => v.args.length === 0);
}

/**
 * Process union types for schema output
 */
function processUnionTypes(unionTypes) {
    return unionTypes.map(ut => ({
        name: ut.name,
        filename: ut.filename,
        isEnumLike: isEnumLike(ut),
        variants: ut.variants.map(v => ({
            name: v.name,
            args: v.args
        })),
        // For enum-like types, provide simple list of variant names
        enumValues: isEnumLike(ut) ? ut.variants.map(v => v.name) : null
    }));
}

/**
 * Parse database models from Elm schema files
 * @param {Object} config - Configuration with paths
 * @returns {Array} Array of parsed types with SQL type info
 */
function parseDbModels(config = {}) {
    const paths = getGenerationPaths(config);
    const schemaDir = paths.elmSchemaDir;

    if (!fs.existsSync(schemaDir)) {
        return [];
    }

    // elm-parser-ts already computes sqlType and constraints via elmTypeToSql
    return parseElmSchemaDir(schemaDir);
}

/**
 * Parse database models AND union types from Elm schema files
 * @param {Object} config - Configuration with paths
 * @returns {{ structs: Array, unionTypes: Array }}
 */
function parseDbModelsFull(config = {}) {
    const paths = getGenerationPaths(config);
    const schemaDir = paths.elmSchemaDir;

    if (!fs.existsSync(schemaDir)) {
        return { structs: [], unionTypes: [] };
    }

    // elm-parser-ts already computes sqlType and constraints via elmTypeToSql
    const { records, unionTypes } = parseElmSchemaDirFull(schemaDir);
    return { structs: records, unionTypes };
}

/**
 * Main SQL schema generation function
 */
export async function generateSqlSchema(config = {}) {
    console.log('ðŸ—ï¸ Generating SQL schema...');

    const paths = getGenerationPaths(config);
    const { structs: allStructs, unionTypes: allUnionTypes } = parseDbModelsFull(config);

    if (allStructs.length === 0) {
        console.log(`ðŸ“ No schema models found at ${paths.elmSchemaDir}, skipping generation`);
        return null;
    }

    console.log(`ðŸ“¦ Using Elm Schema models from ${paths.elmSchemaDir}`);
    console.log(`ðŸ” Found ${allStructs.length} database models: ${allStructs.map(s => s.name).join(', ')}`);

    if (allUnionTypes.length > 0) {
        const enumLikeCount = allUnionTypes.filter(isEnumLike).length;
        console.log(`ðŸ”· Found ${allUnionTypes.length} union types (${enumLikeCount} enum-like): ${allUnionTypes.map(u => u.name).join(', ')}`);
    }

    // Generate schema with FK validation and CHECK constraints for enum-like union types
    const { schema: schemaContent, foreignKeys, warnings } = generateSchema(allStructs, allUnionTypes);

    // Report FK relationships
    if (foreignKeys.length > 0) {
        console.log(`ðŸ”— Foreign keys detected:`);
        for (const fk of foreignKeys) {
            console.log(`   ${fk.table}.${fk.column} â†’ ${fk.referencedTable}.${fk.referencedColumn}`);
        }
    }

    // Report warnings
    if (warnings.length > 0) {
        console.log(`âš ï¸  FK warnings:`);
        for (const warning of warnings) {
            console.log(`   ${warning}`);
        }
    }

    // Output schema.sql to server/.generated/
    const schemaDir = paths.serverGlueDir;

    // Ensure directory exists
    if (!fs.existsSync(schemaDir)) {
        fs.mkdirSync(schemaDir, { recursive: true });
    }

    // Write schema.sql
    const schemaFile = path.join(schemaDir, 'schema.sql');
    fs.writeFileSync(schemaFile, schemaContent);
    console.log(`âœ… Generated schema: ${schemaFile}`);

    return {
        schemaFile,
        models: allStructs.map(s => s.name),
        tables: allStructs.length,
        foreignKeys,
        warnings
    };
}

// Legacy alias
export const generateSqlMigrations = generateSqlSchema;

/**
 * Generate schema introspection JSON
 * Outputs structured metadata for admin UI, documentation, etc.
 */
export async function generateSchemaIntrospection(config = {}) {
    console.log('ðŸ—ï¸ Generating schema introspection...');

    const paths = getGenerationPaths(config);
    const { structs: allStructs, unionTypes: allUnionTypes } = parseDbModelsFull(config);

    if (allStructs.length === 0) {
        console.log(`ðŸ“ No schema models found at ${paths.elmSchemaDir}, skipping generation`);
        return null;
    }

    // Build union type lookup for field type detection
    const unionTypeMap = {};
    for (const ut of allUnionTypes) {
        unionTypeMap[ut.name] = ut;
    }

    // Build table name lookup
    const knownTables = allStructs.map(s => s.tableName);

    // Build introspection data
    const tables = {};
    const relationships = [];

    for (const struct of allStructs) {
        const tableInfo = {
            structName: struct.name,
            tableName: struct.tableName,
            sourceFile: struct.filename,
            fields: {},
            primaryKey: null,
            foreignKeys: [],
            referencedBy: [],
            // MultiTenant and SoftDelete flags for runtime query filtering
            isMultiTenant: struct.isMultiTenant || false,
            isSoftDelete: struct.isSoftDelete || false,
            multiTenantFieldName: struct.multiTenantFieldName || 'host',
            softDeleteFieldName: struct.softDeleteFieldName || 'deleted_at'
        };

        for (const field of struct.fields) {
            const fieldInfo = {
                rustType: field.rustType,
                sqlType: field.sqlType,
                nullable: field.isOptional,
                isPrimaryKey: field.isPrimaryKey,
                isTimestamp: field.isTimestamp || field.isCreateTimestamp || field.isUpdateTimestamp,
                isLink: field.isLink,
                isRichContent: field.isRichContent
            };

            // Check if field type references a union type
            const fieldTypeName = field.rustType.replace(/^Maybe\s+/, '').trim();
            if (unionTypeMap[fieldTypeName]) {
                const ut = unionTypeMap[fieldTypeName];
                fieldInfo.isUnionType = true;
                fieldInfo.unionTypeName = fieldTypeName;
                fieldInfo.isEnumLike = isEnumLike(ut);
                if (fieldInfo.isEnumLike) {
                    fieldInfo.enumValues = ut.variants.map(v => v.name);
                }
            }

            tableInfo.fields[field.name] = fieldInfo;

            if (field.isPrimaryKey) {
                tableInfo.primaryKey = field.name;
            }

            // Only create FK relationships for explicit ForeignKey fields
            if (field.isForeignKey && field.referencedTable) {
                tableInfo.foreignKeys.push({
                    column: field.name,
                    references: {
                        table: field.referencedTable,
                        column: 'id'
                    }
                });

                relationships.push({
                    from: { table: struct.tableName, column: field.name },
                    to: { table: field.referencedTable, column: 'id' },
                    type: 'many-to-one'
                });
            }
        }

        tables[struct.tableName] = tableInfo;
    }

    // Add reverse references (referencedBy)
    for (const rel of relationships) {
        if (tables[rel.to.table]) {
            tables[rel.to.table].referencedBy.push({
                table: rel.from.table,
                column: rel.from.column
            });
        }
    }

    // Detect join tables: no primary key, 2+ FKs, only FK columns + standard fields
    const standardFields = ['host', 'created_at', 'updated_at', 'deleted_at'];
    for (const tableName of Object.keys(tables)) {
        const table = tables[tableName];
        const fkColumns = table.foreignKeys.map(fk => fk.column);

        table.isJoinTable = (
            table.primaryKey === null &&
            table.foreignKeys.length >= 2 &&
            Object.keys(table.fields).every(f =>
                fkColumns.includes(f) || standardFields.includes(f)
            )
        );
    }

    // Detect many-to-many relationships from join tables
    const manyToManyRelationships = [];
    for (const [tableName, table] of Object.entries(tables)) {
        if (table.isJoinTable && table.foreignKeys.length === 2) {
            const [fk1, fk2] = table.foreignKeys;
            manyToManyRelationships.push({
                table1: fk1.references.table,
                table2: fk2.references.table,
                joinTable: tableName
            });
        }
    }

    // Process union types for output
    const enumTypes = processUnionTypes(allUnionTypes);

    const introspection = {
        generatedAt: new Date().toISOString(),
        tables,
        relationships,
        manyToManyRelationships,
        enumTypes,
        summary: {
            tableCount: Object.keys(tables).length,
            relationshipCount: relationships.length,
            joinTableCount: Object.values(tables).filter(t => t.isJoinTable).length,
            manyToManyCount: manyToManyRelationships.length,
            enumTypeCount: enumTypes.length,
            enumLikeCount: enumTypes.filter(e => e.isEnumLike).length
        }
    };

    if (enumTypes.length > 0) {
        console.log(`ðŸ”· Found ${enumTypes.length} union types: ${enumTypes.map(e => e.name).join(', ')}`);
    }

    // Write to schema.json in the server glue directory
    const outputDir = ensureOutputDir(paths.serverGlueDir);

    const schemaFile = path.join(outputDir, 'schema.json');
    fs.writeFileSync(schemaFile, JSON.stringify(introspection, null, 2));
    console.log(`âœ… Generated schema introspection: ${schemaFile}`);

    return {
        schemaFile,
        introspection
    };
}

export default generateSqlSchema;

// Test helpers - export internal functions for unit testing
export const generateCreateTableForTest = generateCreateTable;
export const generateSchemaForTest = generateSchema;
export { isEnumLike, processUnionTypes };
