import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('Hamlet Code Generation Tests', () => {
    
    describe('Generated Files Exist', () => {
        test('all expected files are generated', () => {
            const expectedFiles = [
                '../../generated/api-routes.js',
                '../../generated/browser-storage.js', 
                '../../generated/database-queries.js',
                '../../generated/kv-store.js',
                '../../../../app/generated/ApiClient.elm',
                '../../../../app/generated/StoragePorts.elm'
            ];
            
            expectedFiles.forEach(relativePath => {
                const filePath = path.join(__dirname, relativePath);
                expect(fs.existsSync(filePath)).toBe(true);
            });
        });
    });

    describe('API Route Generation', () => {
        let jsContent, elmContent;
        
        beforeAll(() => {
            const jsFile = path.join(__dirname, '../../generated/api-routes.js');
            const elmFile = path.join(__dirname, '../../../../app/generated/ApiClient.elm');
            
            jsContent = fs.readFileSync(jsFile, 'utf-8');
            elmContent = fs.readFileSync(elmFile, 'utf-8');
        });

        test('JavaScript routes file has correct structure', () => {
            expect(jsContent).toContain('registerApiRoutes');
            expect(jsContent).toContain('/api/SubmitComment');
            expect(jsContent).toContain('/api/GetFeed');
            expect(jsContent).toContain('/api/SubmitItem');
            expect(jsContent).toContain('/api/GetTags');
            expect(jsContent).toContain('DO NOT EDIT THIS FILE MANUALLY');
        });

        test('Elm client has correct structure', () => {
            expect(elmContent).toContain('module Generated.ApiClient exposing');
            expect(elmContent).toContain('submitcomment');
            expect(elmContent).toContain('getfeed'); 
            expect(elmContent).toContain('submititem');
            expect(elmContent).toContain('gettags');
            expect(elmContent).toContain('encodeSubmitCommentReq');
            expect(elmContent).toContain('Http.post');
            expect(elmContent).toContain('DO NOT EDIT THIS FILE MANUALLY');
        });

        test('Elm types match expected structure', () => {
            expect(elmContent).toContain('type alias SubmitCommentReq');
            expect(elmContent).toContain('type alias GetFeedReq');
            expect(elmContent).toContain('type alias SubmitItemReq');
            expect(elmContent).toContain('type alias GetTagsReq');
            expect(elmContent).toContain('host : String');
            expect(elmContent).toContain('title : String');
            expect(elmContent).toContain('tags : List String');
        });
    });

    describe('Database Query Generation', () => {
        let content;
        
        beforeAll(() => {
            const dbFile = path.join(__dirname, '../../generated/database-queries.js');
            content = fs.readFileSync(dbFile, 'utf-8');
        });

        test('has correct structure and exports', () => {
            expect(content).toContain('export default function createDbQueries');
            expect(content).toContain('DO NOT EDIT THIS FILE MANUALLY');
            expect(content).toContain('INSERT INTO');
            expect(content).toContain('SELECT * FROM');
            expect(content).toContain('UPDATE');
            expect(content).toContain('DELETE FROM');
        });

        test('implements SQL injection protection', () => {
            expect(content).toContain('pool.query(');
            expect(content).toContain('$1');
            expect(content).toContain('$2');
            // Should use parameterized queries with arrays
            expect(content).toContain('[');
            expect(content).toContain(']');
            // The string concatenation present is for building parameterized SQL, not direct injection
            // Check that user input goes through parameters, not direct string interpolation
            expect(content).toMatch(/pool\.query\([^,]+,\s*\[/); // Query with parameter array
        });

        test('enforces tenant isolation', () => {
            expect(content).toContain('WHERE host = $');
            expect(content).toContain('AND host = $');
        });
    });

    describe('KV Store Generation', () => {
        let content;
        
        beforeAll(() => {
            const kvFile = path.join(__dirname, '../../generated/kv-store.js');
            content = fs.readFileSync(kvFile, 'utf-8');
        });

        test('has correct structure and functions', () => {
            expect(content).toContain('export default function createKvFunctions');
            expect(content).toContain('setTestCache');
            expect(content).toContain('getTestCache');
            expect(content).toContain('deleteTestCache');
            expect(content).toContain('existsTestCache');
            expect(content).toContain('updateTtlTestCache');
            expect(content).toContain('setUserSession');
            expect(content).toContain('getUserSession');
        });

        test('uses correct Redis operations', () => {
            expect(content).toContain('kvClient.setex');
            expect(content).toContain('kvClient.get');
            expect(content).toContain('kvClient.del');
            expect(content).toContain('kvClient.exists');
            expect(content).toContain('kvClient.expire');
        });

        test('implements tenant isolation', () => {
            expect(content).toContain('host}:testcache:');
            expect(content).toContain('host}:usersession:');
        });

        test('handles TTL and JSON serialization', () => {
            expect(content).toContain('ttl || 3600');
            expect(content).toContain('JSON.stringify');
            expect(content).toContain('JSON.parse');
        });

        test('implements error handling', () => {
            expect(content).toContain('try {');
            expect(content).toContain('} catch (error) {');
            expect(content).toContain('console.error');
            expect(content).toContain('return false');
            expect(content).toContain('return null');
        });
    });

    describe('Browser Storage Generation', () => {
        let jsContent, elmContent;
        
        beforeAll(() => {
            const jsFile = path.join(__dirname, '../../generated/browser-storage.js');
            const elmFile = path.join(__dirname, '../../../../app/generated/StoragePorts.elm');
            
            jsContent = fs.readFileSync(jsFile, 'utf-8');
            elmContent = fs.readFileSync(elmFile, 'utf-8');
        });

        test('JavaScript storage file has correct structure', () => {
            expect(jsContent).toContain('export class UserPreferencesStorage');
            expect(jsContent).toContain('export class AuthStateStorage');
            expect(jsContent).toContain('export function connectStoragePorts');
            expect(jsContent).toContain('ESSENTIAL: This enables direct Elm-to-localStorage communication');
        });

        test('storage classes have required methods', () => {
            const requiredMethods = ['save', 'load', 'clear', 'exists', 'update'];
            requiredMethods.forEach(method => {
                expect(jsContent).toContain(`static ${method}(`);
            });
            
            expect(jsContent).toContain('localStorage.setItem');
            expect(jsContent).toContain('localStorage.getItem');
            expect(jsContent).toContain('localStorage.removeItem');
            expect(jsContent).toContain('JSON.stringify');
            expect(jsContent).toContain('JSON.parse');
        });

        test('Elm port integration is implemented', () => {
            expect(jsContent).toContain('app.ports');
            expect(jsContent).toContain('Changed.send');
            expect(jsContent).toContain('subscribe(');
            expect(jsContent).toContain('typeof app !== \'undefined\'');
        });

        test('Elm port file has correct structure', () => {
            expect(elmContent).toContain('port module Generated.StoragePorts exposing (..)');
            expect(elmContent).toContain('port saveUserPreferences');
            expect(elmContent).toContain('port loadUserPreferences');
            expect(elmContent).toContain('port clearUserPreferences');
            expect(elmContent).toContain('port userpreferencesLoaded');
            expect(elmContent).toContain('port userpreferencesChanged');
        });
    });

    describe('Code Generation Quality', () => {
        test('all generated files have warning headers', () => {
            const generatedFiles = [
                '../../generated/api-routes.js',
                '../../generated/browser-storage.js',
                '../../generated/database-queries.js', 
                '../../generated/kv-store.js',
                '../../../../app/generated/ApiClient.elm',
                '../../../../app/generated/StoragePorts.elm'
            ];
            
            generatedFiles.forEach(relativePath => {
                const filePath = path.join(__dirname, relativePath);
                const content = fs.readFileSync(filePath, 'utf-8');
                expect(content).toContain('DO NOT EDIT THIS FILE MANUALLY');
                expect(content).toContain('Changes will be overwritten during next generation');
            });
        });

        test('no dangerous code patterns exist', () => {
            const jsFiles = [
                '../../generated/api-routes.js',
                '../../generated/browser-storage.js', 
                '../../generated/database-queries.js',
                '../../generated/kv-store.js'
            ];
            
            jsFiles.forEach(relativePath => {
                const filePath = path.join(__dirname, relativePath);
                const content = fs.readFileSync(filePath, 'utf-8');
                
                // No eval or other dangerous functions
                expect(content).not.toContain('eval(');
                expect(content).not.toContain('Function(');
                
                // No unsafe SQL concatenation in database file
                if (relativePath.includes('database-queries')) {
                    // Should not have user input directly concatenated into SQL strings
                    expect(content).not.toMatch(/['"`]\s*\+\s*\w+\./); // Variable access in SQL
                    expect(content).not.toMatch(/\$\{[^}]*\w+\.[^}]*\}/); // Template literals with user data
                }
            });
        });
    });
});