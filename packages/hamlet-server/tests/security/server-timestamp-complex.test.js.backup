import { jest } from '@jest/globals';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('Server-Issued Timestamp Security Tests', () => {

    describe('TEA Handler Timestamp Security', () => {
        let mockElmApp;
        let createElmService;

        beforeEach(async () => {
            // Mock Elm app
            mockElmApp = {
                ports: {
                    handleRequest: { send: jest.fn() },
                    complete: { subscribe: jest.fn() }
                }
            };

            // Mock handler module
            const mockHandlerModule = {
                Elm: {
                    Api: {
                        Handlers: {
                            TestHandler: {
                                init: jest.fn().mockReturnValue(mockElmApp)
                            }
                        }
                    }
                }
            };

            // Mock fs and require
            jest.spyOn(fs, 'existsSync').mockReturnValue(true);
            
            const mockRequire = jest.fn().mockReturnValue(mockHandlerModule);
            jest.mock('module', () => ({
                createRequire: () => mockRequire
            }));

            // Import after mocks
            const { default: elmServiceModule } = await import('../../middleware/elm-service.js');
            createElmService = elmServiceModule;
        });

        afterEach(() => {
            jest.restoreAllMocks();
        });

        test('server issues timestamp at handler initialization', () => {
            const beforeTime = Date.now();
            
            const mockServer = {
                registerService: jest.fn(),
                getService: jest.fn()
            };

            createElmService(mockServer);

            const afterTime = Date.now();

            // Check that init was called with server timestamp
            const initCall = mockElmApp.Elm.Api.Handlers.TestHandler.init.mock.calls[0][0];
            const serverNow = initCall.flags.globalConfig.serverNow;

            expect(typeof serverNow).toBe('number');
            expect(serverNow).toBeGreaterThanOrEqual(beforeTime);
            expect(serverNow).toBeLessThanOrEqual(afterTime);
        });

        test('server timestamp is read-only in GlobalConfig', async () => {
            const testOutputDir = path.join(__dirname, 'temp_timestamp_test');
            
            if (fs.existsSync(testOutputDir)) {
                fs.rmSync(testOutputDir, { recursive: true, force: true });
            }
            fs.mkdirSync(testOutputDir, { recursive: true });

            const originalCwd = process.cwd();
            process.chdir(testOutputDir);

            try {
                const { generateElmSharedModules } = await import('../../../../.buildamp/generation/elm_shared_modules.js');
                await generateElmSharedModules();

                const databaseContent = fs.readFileSync(path.join(testOutputDir, 'Database.elm'), 'utf-8');
                
                // Verify GlobalConfig structure is read-only
                expect(databaseContent).toContain('type alias GlobalConfig =');
                expect(databaseContent).toContain('serverNow : Int');
                expect(databaseContent).toContain('Read-only data that\'s consistent across the request lifecycle');
                
                // Should not have any update functions for GlobalConfig
                expect(databaseContent).not.toContain('updateGlobalConfig');
                expect(databaseContent).not.toContain('setServerNow');

            } finally {
                process.chdir(originalCwd);
                if (fs.existsSync(testOutputDir)) {
                    fs.rmSync(testOutputDir, { recursive: true, force: true });
                }
            }
        });

        test('prevents client-side timestamp manipulation', async () => {
            const mockServer = {
                registerService: jest.fn(),
                getService: jest.fn()
            };

            // Create service twice to simulate different initialization times
            const service1Time = Date.now();
            createElmService(mockServer);
            
            // Wait and create another service
            await new Promise(resolve => setTimeout(resolve, 10));
            const service2Time = Date.now();
            createElmService(mockServer);

            // Each service should get its own server timestamp
            const calls = mockElmApp.Elm.Api.Handlers.TestHandler.init.mock.calls;
            const timestamp1 = calls[0][0].flags.globalConfig.serverNow;
            const timestamp2 = calls[1][0].flags.globalConfig.serverNow;

            expect(timestamp2).toBeGreaterThanOrEqual(timestamp1);
        });
    });

    describe('Generated Handler Timestamp Usage', () => {
        test('generated handlers include getServerTimestamp function', async () => {
            const testOutputDir = path.join(__dirname, 'temp_handler_timestamp');
            
            if (fs.existsSync(testOutputDir)) {
                fs.rmSync(testOutputDir, { recursive: true, force: true });
            }
            
            // Create directory structure
            const dirs = [
                'src/models/api',
                'app/horatio/server/src/Api/Handlers',
                'app/horatio/server/generated'
            ];
            
            dirs.forEach(dir => {
                fs.mkdirSync(path.join(testOutputDir, dir), { recursive: true });
            });

            // Create mock Database.elm
            fs.writeFileSync(
                path.join(testOutputDir, 'app', 'horatio', 'server', 'generated', 'Database.elm'),
                'module Generated.Database exposing (..)'
            );

            // Create API definition
            fs.writeFileSync(
                path.join(testOutputDir, 'src', 'models', 'api', 'timestamp_api.rs'),
                `
#[buildamp_api(path = "TimestampTest")]
pub struct TimestampTestReq {
    pub host: String,
}
                `
            );

            const originalCwd = process.cwd();
            process.chdir(testOutputDir);

            try {
                const { generateElmHandlers } = await import('../../../../.buildamp/generation/elm_handlers.js');
                await generateElmHandlers();

                const handlerContent = fs.readFileSync(
                    path.join(testOutputDir, 'app', 'horatio', 'server', 'src', 'Api', 'Handlers', 'TimestampTestHandler.elm'),
                    'utf-8'
                );

                // Should include timestamp function with security documentation
                expect(handlerContent).toContain('getServerTimestamp : GlobalConfig -> Int');
                expect(handlerContent).toContain('getServerTimestamp config =');
                expect(handlerContent).toContain('config.serverNow');
                expect(handlerContent).toContain('Get server-issued timestamp for reliable time operations');
                expect(handlerContent).toContain('This ensures all timestamps come from the server, preventing client manipulation');

            } finally {
                process.chdir(originalCwd);
                if (fs.existsSync(testOutputDir)) {
                    fs.rmSync(testOutputDir, { recursive: true, force: true });
                }
            }
        });
    });

    describe('Timestamp Security Validation', () => {
        test('server timestamps are within reasonable bounds', () => {
            const mockServer = {
                registerService: jest.fn(),
                getService: jest.fn()
            };

            // Mock the current time to test bounds
            const mockTime = 1609459200000; // 2021-01-01 00:00:00 UTC
            jest.spyOn(Date, 'now').mockReturnValue(mockTime);

            createElmService(mockServer);

            const initCall = mockElmApp.Elm.Api.Handlers.TestHandler.init.mock.calls[0][0];
            const serverNow = initCall.flags.globalConfig.serverNow;

            expect(serverNow).toBe(mockTime);
            expect(serverNow).toBeGreaterThan(1600000000000); // After Sept 2020
            expect(serverNow).toBeLessThan(2000000000000); // Before May 2033

            jest.restoreAllMocks();
        });

        test('multiple handler instances get consistent timestamps', async () => {
            const mockServer = {
                registerService: jest.fn(),
                getService: jest.fn()
            };

            const service = createElmService(mockServer);
            const registeredService = mockServer.registerService.mock.calls[0][1];

            // Mock completion callback
            const mockCleanup = jest.fn();
            mockElmApp.ports.complete.subscribe.mockImplementation(callback => {
                setTimeout(() => callback({ timestamp: Date.now() }), 10);
                return mockCleanup;
            });

            // Make multiple concurrent calls
            const requests = [
                registeredService.callHandler('TestHandler', {}, {}),
                registeredService.callHandler('TestHandler', {}, {}),
                registeredService.callHandler('TestHandler', {}, {})
            ];

            await Promise.all(requests);

            // All calls should use the same server initialization time
            const calls = mockElmApp.ports.handleRequest.send.mock.calls;
            expect(calls.length).toBe(3);

            // The server timestamp in GlobalConfig should be consistent across calls
            // (this is verified in the handler initialization, not in individual calls)
            expect(mockElmApp.Elm.Api.Handlers.TestHandler.init).toHaveBeenCalledTimes(1);
        });

        test('timestamp precision is appropriate for security', () => {
            const mockServer = {
                registerService: jest.fn(),
                getService: jest.fn()
            };

            createElmService(mockServer);

            const initCall = mockElmApp.Elm.Api.Handlers.TestHandler.init.mock.calls[0][0];
            const serverNow = initCall.flags.globalConfig.serverNow;

            // Should be millisecond precision (not second precision)
            expect(serverNow.toString().length).toBeGreaterThan(10); // More than 10 digits
            expect(Number.isInteger(serverNow)).toBe(true);
        });
    });

    describe('Documentation and Security Awareness', () => {
        test('timestamp documentation emphasizes security importance', async () => {
            const testOutputDir = path.join(__dirname, 'temp_docs_test');
            
            if (fs.existsSync(testOutputDir)) {
                fs.rmSync(testOutputDir, { recursive: true, force: true });
            }
            
            const dirs = [
                'src/models/api',
                'app/horatio/server/src/Api/Handlers',
                'app/horatio/server/generated'
            ];
            
            dirs.forEach(dir => {
                fs.mkdirSync(path.join(testOutputDir, dir), { recursive: true });
            });

            fs.writeFileSync(
                path.join(testOutputDir, 'app', 'horatio', 'server', 'generated', 'Database.elm'),
                'module Generated.Database exposing (..)'
            );

            fs.writeFileSync(
                path.join(testOutputDir, 'src', 'models', 'api', 'docs_api.rs'),
                `
#[buildamp_api(path = "DocsTest")]
pub struct DocsTestReq {
    pub host: String,
}
                `
            );

            const originalCwd = process.cwd();
            process.chdir(testOutputDir);

            try {
                const { generateElmHandlers } = await import('../../../../.buildamp/generation/elm_handlers.js');
                await generateElmHandlers();

                const handlerContent = fs.readFileSync(
                    path.join(testOutputDir, 'app', 'horatio', 'server', 'src', 'Api', 'Handlers', 'DocsTestHandler.elm'),
                    'utf-8'
                );

                // Check for security-focused documentation
                expect(handlerContent).toContain('preventing client manipulation');
                expect(handlerContent).toContain('server-issued timestamp');
                expect(handlerContent).toContain('reliable time operations');
                
                // Should include usage examples
                expect(handlerContent).toContain('let');
                expect(handlerContent).toContain('currentTime = getServerTimestamp');
                expect(handlerContent).toContain('model.globalConfig');

            } finally {
                process.chdir(originalCwd);
                if (fs.existsSync(testOutputDir)) {
                    fs.rmSync(testOutputDir, { recursive: true, force: true });
                }
            }
        });

        test('GlobalConfig documentation explains security model', async () => {
            const testOutputDir = path.join(__dirname, 'temp_config_docs');
            
            if (fs.existsSync(testOutputDir)) {
                fs.rmSync(testOutputDir, { recursive: true, force: true });
            }
            fs.mkdirSync(testOutputDir, { recursive: true });

            const originalCwd = process.cwd();
            process.chdir(testOutputDir);

            try {
                const { generateElmSharedModules } = await import('../../../../.buildamp/generation/elm_shared_modules.js');
                await generateElmSharedModules();

                const databaseContent = fs.readFileSync(path.join(testOutputDir, 'Database.elm'), 'utf-8');
                
                // Should document the security model
                expect(databaseContent).toContain('Global configuration provided by server at handler initialization');
                expect(databaseContent).toContain('Read-only data that\'s consistent across the request lifecycle');
                expect(databaseContent).toContain('Server-issued Unix timestamp (milliseconds)');

            } finally {
                process.chdir(originalCwd);
                if (fs.existsSync(testOutputDir)) {
                    fs.rmSync(testOutputDir, { recursive: true, force: true });
                }
            }
        });
    });

    describe('Edge Cases and Error Scenarios', () => {
        test('handles system clock changes gracefully', () => {
            const mockServer = {
                registerService: jest.fn(),
                getService: jest.fn()
            };

            // Simulate system clock going backwards
            let mockTime = Date.now();
            jest.spyOn(Date, 'now').mockImplementation(() => mockTime);

            createElmService(mockServer);
            const timestamp1 = mockElmApp.Elm.Api.Handlers.TestHandler.init.mock.calls[0][0].flags.globalConfig.serverNow;

            // Simulate clock going backwards
            mockTime -= 10000;

            // Create new service (simulating restart)
            createElmService(mockServer);
            const timestamp2 = mockElmApp.Elm.Api.Handlers.TestHandler.init.mock.calls[1][0].flags.globalConfig.serverNow;

            // Should reflect the actual system time, even if it went backwards
            expect(timestamp2).toBe(mockTime);
            expect(timestamp2).toBeLessThan(timestamp1);

            jest.restoreAllMocks();
        });

        test('validates timestamp format and type safety', () => {
            const mockServer = {
                registerService: jest.fn(),
                getService: jest.fn()
            };

            createElmService(mockServer);

            const initCall = mockElmApp.Elm.Api.Handlers.TestHandler.init.mock.calls[0][0];
            const globalConfig = initCall.flags.globalConfig;

            // Type validation
            expect(typeof globalConfig.serverNow).toBe('number');
            expect(Number.isFinite(globalConfig.serverNow)).toBe(true);
            expect(Number.isNaN(globalConfig.serverNow)).toBe(false);
            expect(globalConfig.serverNow > 0).toBe(true);

            // Format validation (should be milliseconds since epoch)
            expect(globalConfig.serverNow.toString()).toMatch(/^\d{13}$/); // 13 digits for milliseconds
        });
    });
});