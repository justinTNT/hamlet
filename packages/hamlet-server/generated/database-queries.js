/**
 * Auto-Generated Database Query Functions
 * Generated from models in src/models/db/
 * 
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * ⚠️  Changes will be overwritten during next generation
 * 
 * This file replaces dangerous SQL string manipulation with type-safe,
 * pre-validated database queries that include automatic tenant isolation.
 */

// Factory function that takes a pool and returns bound query functions
export default function createDbQueries(pool) {
// Auto-generated database functions for ItemComment

/**
 * Insert ItemComment with automatic tenant isolation
 */
async function insertItemComment(itemcomment, host) {
    const result = await pool.query(
        'INSERT INTO item_comment (item_id, guest_id, parent_id, author_name, text, timestamp, host) VALUES ($2, $3, $4, $5, $6, $7, $1) RETURNING *',
        [host, itemcomment.item_id, itemcomment.guest_id, itemcomment.parent_id, itemcomment.author_name, itemcomment.text, itemcomment.timestamp]
    );
    return result.rows[0];
}

/**
 * Get all ItemComments for a tenant
 */
async function getItemCommentsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM item_comment WHERE host = $1 ORDER BY timestamp DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get ItemComment by ID with tenant isolation
 */
async function getItemCommentById(id, host) {
    const result = await pool.query(
        'SELECT * FROM item_comment WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update ItemComment with tenant isolation
 */
async function updateItemComment(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);
    
    if (setClause === '') {
        return getItemCommentById(id, host);
    }
    
    const sql = 'UPDATE item_comment SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Delete ItemComment with tenant isolation
 */
async function deleteItemComment(id, host) {
    const result = await pool.query(
        'DELETE FROM item_comment WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

// Auto-generated database functions for SubmitCommentData

/**
 * Insert SubmitCommentData with automatic tenant isolation
 */
async function insertSubmitCommentData(submitcommentdata, host) {
    const result = await pool.query(
        'INSERT INTO submit_comment_data (existing_guest, fresh_guest_id, fresh_comment_id, host) VALUES ($2, $3, $4, $1) RETURNING *',
        [host, submitcommentdata.existing_guest, submitcommentdata.fresh_guest_id, submitcommentdata.fresh_comment_id]
    );
    return result.rows[0];
}

/**
 * Get all SubmitCommentDatas for a tenant
 */
async function getSubmitCommentDatasByHost(host) {
    const result = await pool.query(
        'SELECT * FROM submit_comment_data WHERE host = $1 ORDER BY timestamp DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get SubmitCommentData by ID with tenant isolation
 */
async function getSubmitCommentDataById(id, host) {
    const result = await pool.query(
        'SELECT * FROM submit_comment_data WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update SubmitCommentData with tenant isolation
 */
async function updateSubmitCommentData(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);
    
    if (setClause === '') {
        return getSubmitCommentDataById(id, host);
    }
    
    const sql = 'UPDATE submit_comment_data SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Delete SubmitCommentData with tenant isolation
 */
async function deleteSubmitCommentData(id, host) {
    const result = await pool.query(
        'DELETE FROM submit_comment_data WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

// Auto-generated database functions for MicroblogItem

/**
 * Insert MicroblogItem with automatic tenant isolation
 */
async function insertMicroblogItem(microblogitem, host) {
    const result = await pool.query(
        'INSERT INTO microblog_items (title, link, image, extract, owner_comment, tags, comments, timestamp, view_count, host) VALUES ($2, $3, $4, $5, $6, $7, $8, $9, $10, $1) RETURNING *',
        [host, microblogitem.title, microblogitem.link, microblogitem.image, microblogitem.extract, microblogitem.owner_comment, microblogitem.tags, microblogitem.comments, microblogitem.timestamp, microblogitem.view_count]
    );
    return result.rows[0];
}

/**
 * Get all MicroblogItems for a tenant
 */
async function getMicroblogItemsByHost(host) {
    // Get basic items
    const itemsResult = await pool.query(
        'SELECT * FROM microblog_items WHERE host = $1 ORDER BY timestamp DESC',
        [host]
    );
    
    // Enrich each item with tags and comments
    const items = [];
    for (const item of itemsResult.rows) {
        // Get tags for this item
        const tagsResult = await pool.query(`
            SELECT t.name 
            FROM tags t 
            JOIN item_tags it ON t.id = it.tag_id 
            WHERE it.item_id = $1
        `, [item.id]);
        
        // Get comments for this item
        const commentsResult = await pool.query(`
            SELECT ic.*, g.name as author_name
            FROM item_comments ic
            LEFT JOIN guests g ON ic.guest_id = g.id
            WHERE ic.item_id = $1
            ORDER BY ic.timestamp ASC
        `, [item.id]);
        
        items.push({
            ...item,
            timestamp: parseInt(item.timestamp),
            tags: tagsResult.rows.map(row => row.name),
            comments: commentsResult.rows.map(row => ({
                id: row.id,
                item_id: row.item_id,
                guest_id: row.guest_id,
                parent_id: row.parent_id,
                author_name: row.author_name || 'Anonymous',
                text: row.text,
                timestamp: parseInt(row.timestamp)
            }))
        });
    }
    
    return items;
}

/**
 * Get MicroblogItem by ID with tenant isolation
 */
async function getMicroblogItemById(id, host) {
    const result = await pool.query(
        'SELECT * FROM microblog_items WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update MicroblogItem with tenant isolation
 */
async function updateMicroblogItem(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);
    
    if (setClause === '') {
        return getMicroblogItemById(id, host);
    }
    
    const sql = 'UPDATE microblog_items SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Delete MicroblogItem with tenant isolation
 */
async function deleteMicroblogItem(id, host) {
    const result = await pool.query(
        'DELETE FROM microblog_items WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

// Auto-generated database functions for SubmitItemData

/**
 * Insert SubmitItemData with automatic tenant isolation
 */
async function insertSubmitItemData(submititemdata, host) {
    const result = await pool.query(
        'INSERT INTO submit_item_data (existing_tags, fresh_tag_ids, host) VALUES ($2, $3, $1) RETURNING *',
        [host, submititemdata.existing_tags, submititemdata.fresh_tag_ids]
    );
    return result.rows[0];
}

/**
 * Get all SubmitItemDatas for a tenant
 */
async function getSubmitItemDatasByHost(host) {
    const result = await pool.query(
        'SELECT * FROM submit_item_data WHERE host = $1 ORDER BY timestamp DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get SubmitItemData by ID with tenant isolation
 */
async function getSubmitItemDataById(id, host) {
    const result = await pool.query(
        'SELECT * FROM submit_item_data WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update SubmitItemData with tenant isolation
 */
async function updateSubmitItemData(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);
    
    if (setClause === '') {
        return getSubmitItemDataById(id, host);
    }
    
    const sql = 'UPDATE submit_item_data SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Delete SubmitItemData with tenant isolation
 */
async function deleteSubmitItemData(id, host) {
    const result = await pool.query(
        'DELETE FROM submit_item_data WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

// Auto-generated database functions for Guest

/**
 * Insert Guest with automatic tenant isolation
 */
async function insertGuest(guest, host) {
    const result = await pool.query(
        'INSERT INTO guest (session_id, created_at, host) VALUES ($2, $3, $1) RETURNING *',
        [host, guest.session_id, guest.created_at]
    );
    return result.rows[0];
}

/**
 * Get all Guests for a tenant
 */
async function getGuestsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM guest WHERE host = $1 ORDER BY timestamp DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get Guest by ID with tenant isolation
 */
async function getGuestById(id, host) {
    const result = await pool.query(
        'SELECT * FROM guest WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update Guest with tenant isolation
 */
async function updateGuest(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);
    
    if (setClause === '') {
        return getGuestById(id, host);
    }
    
    const sql = 'UPDATE guest SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Delete Guest with tenant isolation
 */
async function deleteGuest(id, host) {
    const result = await pool.query(
        'DELETE FROM guest WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

// Auto-generated database functions for Tag

/**
 * Insert Tag with automatic tenant isolation
 */
async function insertTag(tag, host) {
    const result = await pool.query(
        'INSERT INTO tag (name, host) VALUES ($2, $1) RETURNING *',
        [host, tag.name]
    );
    return result.rows[0];
}

/**
 * Get all Tags for a tenant
 */
async function getTagsByHost(host) {
    const result = await pool.query(
        'SELECT * FROM tag WHERE host = $1 ORDER BY timestamp DESC',
        [host]
    );
    return result.rows;
}

/**
 * Get Tag by ID with tenant isolation
 */
async function getTagById(id, host) {
    const result = await pool.query(
        'SELECT * FROM tag WHERE id = $1 AND host = $2',
        [id, host]
    );
    return result.rows[0] || null;
}

/**
 * Update Tag with tenant isolation
 */
async function updateTag(id, updates, host) {
    const updateFields = Object.keys(updates).filter(key => key !== 'id' && key !== 'host');
    const setClause = updateFields.map((field, i) => field + ' = $' + (i + 3)).join(', ');
    const values = updateFields.map(field => updates[field]);
    
    if (setClause === '') {
        return getTagById(id, host);
    }
    
    const sql = 'UPDATE tag SET ' + setClause + ', updated_at = NOW() WHERE id = $1 AND host = $2 RETURNING *';
    const result = await pool.query(sql, [id, host, ...values]);
    return result.rows[0] || null;
}

/**
 * Delete Tag with tenant isolation
 */
async function deleteTag(id, host) {
    const result = await pool.query(
        'DELETE FROM tag WHERE id = $1 AND host = $2 RETURNING id',
        [id, host]
    );
    return result.rows.length > 0;
}

    // Return all functions bound to the pool
    return {
        insertItemComment,
        getItemCommentsByHost,
        getItemCommentById,
        updateItemComment,
        deleteItemComment,
        insertSubmitCommentData,
        getSubmitCommentDatasByHost,
        getSubmitCommentDataById,
        updateSubmitCommentData,
        deleteSubmitCommentData,
        insertMicroblogItem,
        getMicroblogItemsByHost,
        getMicroblogItemById,
        updateMicroblogItem,
        deleteMicroblogItem,
        insertSubmitItemData,
        getSubmitItemDatasByHost,
        getSubmitItemDataById,
        updateSubmitItemData,
        deleteSubmitItemData,
        insertGuest,
        getGuestsByHost,
        getGuestById,
        updateGuest,
        deleteGuest,
        insertTag,
        getTagsByHost,
        getTagById,
        updateTag,
        deleteTag
    };
}
