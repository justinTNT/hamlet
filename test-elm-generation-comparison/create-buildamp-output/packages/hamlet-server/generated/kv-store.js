/**
 * Auto-Generated KV Store Functions
 * Generated from models in src/models/kv/
 * 
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * ⚠️  Changes will be overwritten during next generation
 * 
 * This file provides type-safe KV store operations (Redis/etc.)
 * with automatic tenant isolation and TTL management.
 */

// Factory function that takes a KV client and returns bound functions
export default function createKvFunctions(kvClient) {

// Auto-generated KV store functions for TestCache

/**
 * Set TestCache in KV store with TTL and tenant isolation
 * @param {Object} testcache - TestCache data to store
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 */
async function setTestCache(testcache, key, host, kvClient) {
    try {
        const tenantKey = `${host}:testcache:${key}`;
        const ttl = testcache.ttl || 3600; // Default 1 hour if no TTL specified
        
        const serialized = JSON.stringify(testcache);
        await kvClient.setex(tenantKey, ttl, serialized);
        
        return true;
    } catch (error) {
        console.error(`Error setting TestCache:`, error);
        return false;
    }
}

/**
 * Get TestCache from KV store with tenant isolation
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {Object|null} TestCache data or null if not found/expired
 */
async function getTestCache(key, host, kvClient) {
    try {
        const tenantKey = `${host}:testcache:${key}`;
        const data = await kvClient.get(tenantKey);
        
        if (!data) {
            return null;
        }
        
        return JSON.parse(data);
    } catch (error) {
        console.error(`Error getting TestCache:`, error);
        return null;
    }
}

/**
 * Delete TestCache from KV store with tenant isolation
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation  
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {boolean} True if deleted, false otherwise
 */
async function deleteTestCache(key, host, kvClient) {
    try {
        const tenantKey = `${host}:testcache:${key}`;
        const result = await kvClient.del(tenantKey);
        return result === 1;
    } catch (error) {
        console.error(`Error deleting TestCache:`, error);
        return false;
    }
}

/**
 * Check if TestCache exists in KV store with tenant isolation
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {boolean} True if exists, false otherwise
 */
async function existsTestCache(key, host, kvClient) {
    try {
        const tenantKey = `${host}:testcache:${key}`;
        const result = await kvClient.exists(tenantKey);
        return result === 1;
    } catch (error) {
        console.error(`Error checking TestCache exists:`, error);
        return false;
    }
}

/**
 * Update TTL for TestCache in KV store
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {number} ttl - New TTL in seconds
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {boolean} True if TTL updated, false otherwise
 */
async function updateTtlTestCache(key, ttl, host, kvClient) {
    try {
        const tenantKey = `${host}:testcache:${key}`;
        const result = await kvClient.expire(tenantKey, ttl);
        return result === 1;
    } catch (error) {
        console.error(`Error updating TestCache TTL:`, error);
        return false;
    }
}

// Auto-generated KV store functions for UserProfile

/**
 * Set UserProfile in KV store with TTL and tenant isolation
 * @param {Object} userprofile - UserProfile data to store
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 */
async function setUserProfile(userprofile, key, host, kvClient) {
    try {
        const tenantKey = `${host}:userprofile:${key}`;
        const ttl = userprofile.ttl || 3600; // Default 1 hour if no TTL specified
        
        const serialized = JSON.stringify(userprofile);
        await kvClient.setex(tenantKey, ttl, serialized);
        
        return true;
    } catch (error) {
        console.error(`Error setting UserProfile:`, error);
        return false;
    }
}

/**
 * Get UserProfile from KV store with tenant isolation
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {Object|null} UserProfile data or null if not found/expired
 */
async function getUserProfile(key, host, kvClient) {
    try {
        const tenantKey = `${host}:userprofile:${key}`;
        const data = await kvClient.get(tenantKey);
        
        if (!data) {
            return null;
        }
        
        return JSON.parse(data);
    } catch (error) {
        console.error(`Error getting UserProfile:`, error);
        return null;
    }
}

/**
 * Delete UserProfile from KV store with tenant isolation
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation  
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {boolean} True if deleted, false otherwise
 */
async function deleteUserProfile(key, host, kvClient) {
    try {
        const tenantKey = `${host}:userprofile:${key}`;
        const result = await kvClient.del(tenantKey);
        return result === 1;
    } catch (error) {
        console.error(`Error deleting UserProfile:`, error);
        return false;
    }
}

/**
 * Check if UserProfile exists in KV store with tenant isolation
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {boolean} True if exists, false otherwise
 */
async function existsUserProfile(key, host, kvClient) {
    try {
        const tenantKey = `${host}:userprofile:${key}`;
        const result = await kvClient.exists(tenantKey);
        return result === 1;
    } catch (error) {
        console.error(`Error checking UserProfile exists:`, error);
        return false;
    }
}

/**
 * Update TTL for UserProfile in KV store
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {number} ttl - New TTL in seconds
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {boolean} True if TTL updated, false otherwise
 */
async function updateTtlUserProfile(key, ttl, host, kvClient) {
    try {
        const tenantKey = `${host}:userprofile:${key}`;
        const result = await kvClient.expire(tenantKey, ttl);
        return result === 1;
    } catch (error) {
        console.error(`Error updating UserProfile TTL:`, error);
        return false;
    }
}

// Auto-generated KV store functions for UserSession

/**
 * Set UserSession in KV store with TTL and tenant isolation
 * @param {Object} usersession - UserSession data to store
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 */
async function setUserSession(usersession, key, host, kvClient) {
    try {
        const tenantKey = `${host}:usersession:${key}`;
        const ttl = usersession.ttl || 3600; // Default 1 hour if no TTL specified
        
        const serialized = JSON.stringify(usersession);
        await kvClient.setex(tenantKey, ttl, serialized);
        
        return true;
    } catch (error) {
        console.error(`Error setting UserSession:`, error);
        return false;
    }
}

/**
 * Get UserSession from KV store with tenant isolation
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {Object|null} UserSession data or null if not found/expired
 */
async function getUserSession(key, host, kvClient) {
    try {
        const tenantKey = `${host}:usersession:${key}`;
        const data = await kvClient.get(tenantKey);
        
        if (!data) {
            return null;
        }
        
        return JSON.parse(data);
    } catch (error) {
        console.error(`Error getting UserSession:`, error);
        return null;
    }
}

/**
 * Delete UserSession from KV store with tenant isolation
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation  
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {boolean} True if deleted, false otherwise
 */
async function deleteUserSession(key, host, kvClient) {
    try {
        const tenantKey = `${host}:usersession:${key}`;
        const result = await kvClient.del(tenantKey);
        return result === 1;
    } catch (error) {
        console.error(`Error deleting UserSession:`, error);
        return false;
    }
}

/**
 * Check if UserSession exists in KV store with tenant isolation
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {boolean} True if exists, false otherwise
 */
async function existsUserSession(key, host, kvClient) {
    try {
        const tenantKey = `${host}:usersession:${key}`;
        const result = await kvClient.exists(tenantKey);
        return result === 1;
    } catch (error) {
        console.error(`Error checking UserSession exists:`, error);
        return false;
    }
}

/**
 * Update TTL for UserSession in KV store
 * @param {string} key - Cache key (will be prefixed with tenant)
 * @param {number} ttl - New TTL in seconds
 * @param {string} host - Tenant host for isolation
 * @param {Object} kvClient - KV store client (Redis/etc.)
 * @returns {boolean} True if TTL updated, false otherwise
 */
async function updateTtlUserSession(key, ttl, host, kvClient) {
    try {
        const tenantKey = `${host}:usersession:${key}`;
        const result = await kvClient.expire(tenantKey, ttl);
        return result === 1;
    } catch (error) {
        console.error(`Error updating UserSession TTL:`, error);
        return false;
    }
}


    // Return all functions bound to the KV client
    return {
        setTestCache,
        getTestCache,
        deleteTestCache,
        existsTestCache,
        updateTtlTestCache,
        setUserProfile,
        getUserProfile,
        deleteUserProfile,
        existsUserProfile,
        updateTtlUserProfile,
        setUserSession,
        getUserSession,
        deleteUserSession,
        existsUserSession,
        updateTtlUserSession
    };
}

/**
 * Helper: Clean up expired keys for a tenant
 * @param {string} host - Tenant host
 * @param {Object} kvClient - KV store client
 * @returns {number} Number of keys cleaned up
 */
export async function cleanupExpiredKeys(host, kvClient) {
    try {
        const pattern = `${host}:*`;
        const keys = await kvClient.keys(pattern);
        
        let cleaned = 0;
        for (const key of keys) {
            const ttl = await kvClient.ttl(key);
            if (ttl === -1) { // Key exists but no TTL
                await kvClient.expire(key, 3600); // Set default 1 hour TTL
            } else if (ttl === -2) { // Key expired
                cleaned++;
            }
        }
        
        return cleaned;
    } catch (error) {
        console.error('Error cleaning up expired keys:', error);
        return 0;
    }
}

/**
 * Helper: Get all cache keys for a tenant
 * @param {string} host - Tenant host
 * @param {Object} kvClient - KV store client
 * @returns {Array} Array of cache keys for the tenant
 */
export async function getTenantKeys(host, kvClient) {
    try {
        const pattern = `${host}:*`;
        return await kvClient.keys(pattern);
    } catch (error) {
        console.error('Error getting tenant keys:', error);
        return [];
    }
}
